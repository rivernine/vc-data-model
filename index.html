<!DOCTYPE html>
<html lang=ko>

<head>
  <title>검증가능한 크리덴셜 데이터 모델 1.0</title>
  <meta http-equiv='Content-Type' content='text/html;charset=utf-8' />
  <!--
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->
  <script src='https://www.w3.org/Tools/respec/respec-w3c-common' class='remove'></script>
  <script src="./common.js" class="remove"></script>
  <script type="text/javascript" class="remove">
    var respecConfig = {
      // specification status (e.g., WD, LCWD, NOTE, etc.). If in doubt use ED.
      specStatus: "REC",

      // the specification's short name, as in http://www.w3.org/TR/short-name/
      shortName: "vc-data-model",

      // subtitle for the spec
      subtitle: "웹에서 검증가능한 정보를 표현하는법",

      // if you wish the publication date to be other than today, set this
      publishDate: "2019-11-19",
      //crEnd: "2019-08-21",
      //prEnd: "2019-10-01",
      implementationReportURI: "https://w3c.github.io/vc-test-suite/implementations/",
      previousMaturity: "PR",
      previousPublishDate: "2019-09-05",

      // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
      // and its maturity status
      // previousPublishDate:  "1977-03-15",
      // previousMaturity:  "WD",

      // extend the bibliography entries
      localBiblio: vcwg.localBiblio,
      doJsonLd: true,

      github: "https://github.com/w3c/vc-data-model/",
      includePermalinks: false,

      // if there a publicly available Editor's Draft, this is the link
      edDraftURI: "https://w3c.github.io/vc-data-model/",

      // if this is a LCWD, uncomment and set the end of its review period
      // lcEnd: "2009-08-05",

      // editors, add as many as you like
      // only "name" is required
      editors: [
        {
          name: "Manu Sporny", url: "https://www.linkedin.com/in/manusporny/",
          company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/"
        },
        {
          name: "Grant Noble", url: "https://www.linkedin.com/in/grant-noble-8253994a/",
          company: "ConsenSys", companyURL: "https://consensys.net/"
        },
        {
          name: "Dave Longley", url: "https://github.com/dlongley",
          company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/"
        },
        {
          name: "Daniel C. Burnett", url: "https://www.linkedin.com/in/daburnett/",
          company: "ConsenSys", companyURL: "https://consensys.net/"
        },
        {
          name: "Brent Zundel", url: "https://www.linkedin.com/in/bzundel/",
          company: "Evernym", companyURL: "https://evernym.com/"
        }
      ],
      // authors, add as many as you like.
      // This is optional, uncomment if you have authors as well as editors.
      // only "name" is required. Same format as editors.
      authors:
        [
          {
            name: "Manu Sporny", url: "http://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/"
          },
          {
            name: "Dave Longley", url: "http://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/"
          },
          {
            name: "David Chadwick", url: "https://www.linkedin.com/in/david-chadwick-36816395/",
            company: "University of Kent", companyURL: "https://www.kent.ac.uk/"
          }
        ],
      // name of the WG
      wg: "Verifiable Claims Working Group",

      // URI of the public WG page
      wgURI: "https://www.w3.org/2017/vc/",

      // name (with the @w3c.org) of the public mailing to which comments are due
      wgPublicList: "public-vc-comments",

      // URI of the patent status for this WG, for Rec-track documents
      // !!!! IMPORTANT !!!!
      // This is important for Rec-track documents, do not copy a patent URI from a random
      // document unless you know what you're doing. If in doubt ask your friendly neighborhood
      // Team Contact.
      wgPatentURI: "https://www.w3.org/2004/01/pp-impl/98922/status",
      maxTocLevel: 2,
      inlineCSS: true,
      errata: "https://w3c.github.io/vc-data-model/errata.html"
    };
  </script>
  <style>
    pre .highlight {
      font-weight: bold;
      color: Green;
    }

    pre .subject {
      font-weight: bold;
      color: RoyalBlue;
    }

    pre .property {
      font-weight: bold;
      color: DarkGoldenrod;
    }

    pre .comment {
      font-weight: bold;
      color: SteelBlue;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    .color-text {
      font-weight: bold;
      text-shadow: -1px 0 black, 0 1px black, 1px 0 black, 0 -1px black;
    }
  </style>
</head>

<body>
  <div class="advisement" style="font-size:small">
    <p>
      이 문서는 <a href="https://www.w3.org/TR/vc-data-model/">W3C Verifiable Credentials Data Model v1.0</a>의 한국어
      번역본입니다.
    </p>
    <p>
      이 문서에 오역 및 오타를 포함할 수 있다. <b>영어 원문만이 공식적이고 규범적인 효력을 가지고 있다.</b><br />
      문의나 개선사항은 <a href="https://github.com/ssimeetupkorea/ssimeetupkorea.github.io">깃헙 링크</a>나 <a
        href="mailto:jshim10@illinois.edu">jshim10@illinois.edu</a>로 연락주시기 바랍니다.<br />
    </p>

    <p>
      원문작성일: 2019-11-19<br />
      최초번역일: 2020-01-11<br />
      최종수정일: 2020-05-22<br />
    </p>
    <dt><span style="font-weight: 500;">에디터 (가나다순)</span>: </dt>
    <dd><a href="https://www.linkedin.com/in/jaehoonjshim/" ]>심재훈</a></dd>
    <dd><a href="https://www.linkedin.com/in/minho-yoo-1b968837/" ]>유민호</a> (<a href="https://iotrust.kr/">IoTrust
        Co.,Ltd.</a>)</dd>
    <dd><a href="mailto:projector301@gmail.com" ]>윤희태</a> (<a href="https://http://blockcrafters.com/">Block Crafters
        Co.,Ltd.</a>)</dd>
    <dd><a href="mailto:daoauth@gmail.com" ]>임도형</a></dd>
    <dd>&nbsp;</dd>
    <dt><span style="font-weight: 500;">번역자 (가나다순)</span>: </dt>
    <dd><a href="mailto:anh1026@kaist.ac.kr" ]>안형철</a></dd>
    <dd><a href="mailto:magnified02@gmail.com" ]>유수웅</a></dd>
    <dd><a href="mailto:hyunsy822@gmail.com" ]>현수영</a></dd>
  </div>
  <section id='abstract'>
    <p>
      <a>크리덴셜</a>(자격)은 우리 일상 생활의 일부이다. 운전면허증은 우리가 자동차를
      운전할 수 있음을 주장하는데 사용하고, 대학 학위는 교육 수준을 주장하는데 사용하며,
      정부가 발급한 여권은 국가 간 여행을 가능하게 한다. 본 사양에서는 웹 상에서 이러한
      종류의 <a>크리덴셜</a>을 암호학적으로 안전하고, 프라이버시를 존중하며, 기계가 읽을 수 있는
      방식으로 표현하는 메커니즘을 제공한다.
    </p>
  </section>

  <section id='sotd'>
    <!-- 이 부분은 영어 부분을 대채할 수 없기 때문에 삭제 -->
    <p>
      The Working Group thanks the following individuals not only for their
      contributions toward the content of this document, but also for yeoman's work
      in this standards community that drove changes, discussion, and consensus among
      a sea of varied opinions: Matt Stone, Gregg Kellogg, Ted Thibodeau Jr, Oliver
      Terbu, Joe Andrieu, David I. Lehn, Matthew Collier, and Adrian Gropper.
    </p>

    <p>
      Work on this specification has been supported by the Rebooting the
      Web of Trust community facilitated by Christopher Allen, Shannon Appelcline,
      Kiara Robles, Brian Weller, Betty Dhamers, Kaliya Young, Manu Sporny,
      Drummond Reed, Joe Andrieu, Heather Vescent, Kim Hamilton Duffy, Samantha Chase,
      and Andrew Hughes. The participants in the Internet Identity Workshop,
      facilitated by Phil Windley, Kaliya Young, Doc Searls, and Heidi Nobantu Saul,
      also supported the refinement of this work through numerous working sessions
      designed to educate about, debate on, and improve this specification.
    </p>

    <p>
      The Working Group also thanks the Chairs, Dan Burnett and Matt Stone, as
      well as our W3C Staff Contact, Kazuyuki Ashimura, for their expert
      management and steady guidance of the group through the W3C standardization
      process.
    </p>
  </section>
  <section class="informative">
    <h2>소개</h2>

    <p>
      <a>크리덴셜</a>(자격)은 우리 일상 생활의 일부이다. 운전면허증은 우리가 자동차를
      운전할 수 있음을 주장하는데 사용하고, 대학 학위는 교육 수준을 주장하는데 사용하며,
      정부가 발급한 여권은 국가 간 여행을 가능하게 한다. 이러한 <a>크리덴셜</a>은
      물리적 환경에서 사용할 때는 우리에게 이점을 제공하지만, 웹에서 사용하기는 어렵다.
    </p>

    <p>
      현재 웹에서 교육 자격, 의료 데이터, 금융 계정 정보 및 기타 제 3 자의 기계적
      <a>검증</a>(판독)이 가능한 개인 정보를 표현하기는 어렵다.
      웹에서 디지털 <a>크리덴셜</a>을 표현하는 것이 어렵기 때문에 실제 세계에서
      물리적 <a>크리덴셜</a>이 제공하는 것과 동일한 인정을 받기가 어렵다.
    </p>

    <p>
      본 사양에서는 웹 상에서 이러한 종류의 <a>크리덴셜</a>을 암호학적으로 안전하고,
      프라이버시를 존중하며, 기계가 읽을 수 있는 방식으로 표현하는 메커니즘을 제공한다.
    </p>

    <p>
      <a>검증가능한 크리덴셜</a>과 관련된 개념에 익숙치 않은 분들을 위해,
      다음 섹션에서는 다음과 같은 개요를 제공한다.
    </p>

    <ul>
      <li>
        <a>검증가능한 크리덴셜</a>을 구성하는 요소
      </li>
      <li>
        <a>검증가능한 프레젠테이션</a>을 구성하는 요소
      </li>
      <li>
        <a>검증가능한 크리덴셜</a>과 <a>검증가능한 프레젠테이션</a>이 유용할 것으로 기대되는 생태계
      </li>
      <li>
        본 사양에 영향을 미치는 요구사항과 활용 사례
      </li>
    </ul>

    <section class="informative" id="what-is-a-verifiable-credential">
      <h3>검증가능한 크리덴셜은 무엇인가?</h3>

      <p>
        물리적 환경에서 <a>크리덴셜</a>은 다음과 같은 구성으로 구성될 수 있다.
      </p>

      <ul>
        <li>
          <a>크리덴셜</a> <a>주체</a>의 식별과 관련된 정보(예: 사진, 이름 또는 식별 번호)
        </li>
        <li>
          발행 기관과 관련된 정보(예: 시 정부, 국가 기관 또는 인증 기관)
        </li>
        <li>
          <a>크리덴셜</a> 유형과 관련된 정보
          (예: 네덜란드 여권, 미국 운전 면허증 또는 건강 보험증)
        </li>
        <li>
          발행 기관이 <a>주체</a>에 대해 주장하는 특정 속성과 관련된 정보
          (예: 국적, 운전 할 자격이 있는 차량의 클래스 또는 생년월일)
        </li>
        <li>
          <a>크리덴셜</a>이 파생된 방법에 대한 증거
        </li>
        <li>
          크리덴셜의 제약 조건과 관련된 정보(예: 만료 날짜 또는 사용 약관).
        </li>
      </ul>

      <p>
        <a>검증가능한 크리덴셜</a>은 물리적 <a>크리덴셜</a>이 나타내는 것과 동일한
        모든 정보를 나타낼 수 있다. <a>검증가능한 크리덴셜</a>은 디지털 서명과 같은
        기술이 추가를 통해 물리적 <a>크리덴셜</a>보다 신뢰할 수 있고 변조확인이
        가능하도록(Tamper-evident) 만들 수 있다.
      </p>

      <p>
        <a>검증가능한 크리덴셜</a>의 <a>보유자</a>는 <a>검증가능한 프레젠테이션</a>을
        생성한 다음 <a>검증가능한 프레젠테이션</a>을 <a>검증자</a>와 공유하여 특정 특성을
        가진 <a>검증가능한 크리덴셜</a>을 보유하고 있음을 증명할 수 있다.
      </p>

      <p>
        <a>검증가능한 크리덴셜</a>과 <a>검증가능한 프레젠테이션</a>은 신속하게
        전송 가능하므로, 먼 거리에서의 신뢰를 구축하려고 할 때 물리적 크리덴셜보다 더 편리하다.
      </p>

      <p>
        본 사양의 목표는 디지털 <a>크리덴셜</a> 표현의 용이성을 향상시키려는 것이지만,
        그와 더불어 개인 정보 보호 목표와의 균형을 맞추고자 한다.
        디지털 정보의 지속성과 이질적인 디지털 데이터 소스를 수집하고 상호 연관시킬 수 있는
        용이성은 검증가능하고 쉽게 기계적 <a>검증가능한</a> <a>크리덴셜</a>의 사용이
        악화될 수 있다는 개인 정보 보호 우려를 포함한다.
        본 문서의 섹션 <a href="#privacy-considerations"></a>에서 개인 프라이버시
        고려사항에서 이러한 여러 문제를 간략하게 다룬다. 또한 문서 전체적으로
        영지식증명(Zero-knowledge Proof)와 같은 프라이버시 향상 기술이 사용된
        데이터 모델을 어떻게 활용할 수 있는지 예제도 제공한다.
      </p>
    </section>

    <section class="informative" id="ecosystem-overview">
      <h3>생태계 개요</h3>

      <p>
        본 섹션에서는 <a>검증가능한 크리덴셜</a>이 유용할 것으로 예상되는 생태계에서
        핵심 행위자들의 역할과 그들 간의 관계에 대해 설명한다. 역할은 여러 가지 방법으로
        구현될 수 있는 추상화이다. 역할의 분리는 표준화를 위한 인터페이스와 프로토콜을
        암시한다. 이 사양에서는 다음과 같은 역할이 등장한다:
      </p>

      <dl>
        <dt><a>보유자</a> holder </dt>
        <dd>
          하나 이상의 <a>검증가능한 크리덴셜</a>을 보유하고 그것으로부터
          <a>검증가능한 프레젠테이션</a>을 생성하는 역할.
          <a>보유자</a>의 사례로는 학생, 직원 및 고객 등이 있다.
        </dd>
        <dt><a>발급자</a> issuer</dt>
        <dd>
          하나 이상의 <a>주체</a>에 대한 <a>클레임</a>을 확증하고,
          이러한 <a>클레임</a>으로부터 <a>검증가능한 크리덴셜</a>을 생성하며,
          <a>보유자</a>에게 <a>검증가능한 크리덴셜</a>을 전달하는 역할. <a>발급자</a>의
          사례로는 회사, 비영리 단체, 무역 협회, 정부, 개인 등이 있다.
        </dd>
        <dt><a>주체</a> subject</dt>
        <dd>
          <a>클레임</a>의 대상이 되는 <a>엔터티</a>.
          주체의 사례로는 인간, 동물 그리고 사물이있다. 대부분의 경우 <a>검증가능한 크리덴셜</a>의
          <a>보유자</a>가 주체이지만 경우에 따라서는 그렇지 않다.
          예를 들면, 부모(<a>보유자</a>)는 자녀(<a>주체</a>)의 <a>검증가능한 크리덴셜</a>을
          보유하거나 애완동물 소유자(<a>보유자</a>)가 애완동물의
          <a>검증가능한 크리덴셜</a>(<a>주체</a>)을 보유할 수 있다.
          이러한 특수한 경우에 대한 자세한 내용은
          부록 <a href="#subject-holder-relationships"></a>참조.
        </dd>
        <dt><a>검증자</a> verifier</dt>
        <dd>
          검증 절차를 위해 하나 이상의 <a>검증가능한 크리덴셜</a>, 혹은
          <a>검증가능한 프레젠테이션</a>을 받는 역할. <a>검증자</a>의
          사례로는 직원, 보안 담당자, 웹사이트 등이 있다.
        </dd>
        <dt><a>검증가능한 데이터 레지스트리</a> verifiable data registry</dt>
        <dd>
          <a>검증가능한 크리덴셜</a> 스키마, 폐기 레지스트리, 발급자 공개 키 등과 같은 식별자,
          키 및 기타 관련 데이터의 생성 및 확인을 중재하는 역할.
          검증가능한 데이터 레지스트리에는 신뢰할 수 있는 데이터베이스, 분산된 데이터베이스,
          정부 ID 데이터베이스 및 분산 원장이 포함된다. 종종 생태계에 사용되는
          검증가능한 데이터 레지스트리 유형이 두 개 이상 있다.
        </dd>
      </dl>

      <figure id="roles">
        <img style="margin: auto; display: block; width: 75%;" src="diagrams/ecosystem.svg" alt="diagram showing how
	       credentials flow from issuer to holder and
	       presentations flow from holder to verifier where all
	       three parties can use information from a logical
	       verifiable data registry">
        <figcaption style="text-align: center;">
          본 사양의 기초를 형성하는 역할과 정보 흐름도.
        </figcaption>
      </figure>

      <p class="note">
        위의 그림 <a href="#roles"></a> 은 본 명세서의 나머지 개념을 접목하는
        예제 생태계를 제공한다. 보호된 환경이나 독점 시스템과 같은 다른 생태계도 존재하며,
        여기서도 <a>검증가능한 크리덴셜</a>는 이점을 제공한다.
      </p>
    </section>

    <section class="informative" id="use-cases-and-requirements">
      <h3>유스케이스와 요구 사항</h3>

      <p>
        검증가능한 크리덴셜 유스케이스 문서 [[VC-USECASES]]는 독자가 유용하게 사용할 수 있는 여러 가지 주요 주제를 간략하게 설명한다:

      </p>

      <ul>
        <li>
          위에서 소개한 <a href="https://www.w3.org/TR/vc-use-cases/#user-roles">역할</a>에 대한 보다 자세한 설명
        </li>
        <li>
          교육, 금융, 의료, 소매, 전문 라이센스 및 정부와 같은 시장에서 확인된
          <a href="https://www.w3.org/TR/vc-use-cases/#user-needs">요구 사항</a>
        </li>
        <li>
          생태계의 역할에 의해 수행되는 일반적인
          <a href="https://www.w3.org/TR/vc-use-cases/#user-tasks">작업</a>과
          관련된 요구 사항
        </li>
        <li>
          워킹 그룹에서 식별한 공통
          <a href="https://www.w3.org/TR/vc-use-cases/#user-sequences">시퀀스 및 흐름</a>
        </li>
      </ul>

      <p>
        유스케이스 문서를 문서화하고 분석한 결과,
        이 사양에 대해 다음과 같은 바람직한 생태계 특성이 확인되었다:
      </p>
      <!-- requirement list start -->
      <ul>
        <li>
          <a>검증가능한 크리덴셜</a>은 변조 검증이 가능하고 개인 정보 보호에 중요한 방식으로 <a>발급자</a>가 작성한 진술을 나타낸다.
        </li>
        <li>
          <a>보유자</a>는 다른 <a>발급자</a>의 <a>검증가능한 크리덴셜</a> 컬렉션을 단일 아티팩트,
          <a>검증가능한 프레젠테이션</a>으로 수집한다.
        </li>
        <li>
          <a>발급자</a>는 모든 <a>주체</a>에 대해 <a>검증가능한 크리덴셜</a>을 발급할 수 있다.
        </li>
        <li>
          <a>발급자</a>, <a>보유자</a> 또는 <a>검증자</a>로서 행동하는 것은 당사자 간에
          신뢰 관계이기 때문에 어떤 당국의 등록이나 승인이 필요하지 않다.
        </li>
        <li>
          <a>검증가능한 프레젠테이션</a>을 통해 모든 <a>검증자</a>가 <a>발급자</a>로부터
          <a>검증가능한 크리덴셜</a>의 신뢰성을 확인할 수 있다.
        </li>
        <li>
          <a>보유자</a>는 누구에게나 <a>검증가능한 크리덴셜</a>을 받을 수 있다.
        </li>
        <li>

          <a>보유자</a>는 아무 사용자 에이전트를 통해 모든 <a>발급자</a> 및
          <a>검증자</a>와 상호 작용할 수 있다.
        </li>
        <li>
          <a>보유자</a>는 <a>검증가능한 프레젠테이션</a>을 공유할 수 있으며,
          이 <a>검증가능한 프레젠테이션</a>은 <a>발급자</a>에게 <a>검증자</a>의 신원을
          공개하지 않고 <a>검증</a>할 수 있다.
        </li>
        <li>
          <a>보유자</a>는 <a>검증가능성</a>에 영향을 미치지 않고 <a>발급자</a>가 저장위치 또는
          액세스 시기에 대해 전혀 알지 못하면서도 <a>검증가능한 크리덴셜</a>을 저장할 수 있다.
        </li>
        <li>
          <a>보유자</a>는 클레임의 신뢰성에 영향을 미치지 않고 <a>발급자</a>에 해당 조치를
          공개하지 않고 <a>검증가능한 프레젠테이션</a>을 모든 <a>검증자</a>에게 제출할 수 있다.
        </li>
        <li>
          <a>검증자</a>는 모든 <a>발급자</a>의 <a>클레임</a> 증명을 포함하는 모든
          <a>보유자</a>의 <a>검증가능한 프레젠테이션</a>을 <a>검증</a>할 수 있다.
        </li>
        <li>
          <a>검증</a>은 <a>발급자</a>와 <a>검증자</a> 간의 직접적인 상호 작용에 의존하지 않는다.
        </li>
        <li>
          <a>검증</a>은 어떤 <a>발급자</a>에게도 <a>검증자</a>의 신원을 공개하지 않아야한다.
        </li>
        <li>
          이 사양은 <a>발급자</a>가 해당 기능을 지원하기 위해 모든 준수한 소프트웨어가 필요 없이
          선택적 공개를 지원하는 <a>검증가능한 크리덴셜</a>을 발급할 수 있는 수단을 제공해야 한다.
        </li>
        <li>
          <a>발급자</a>는 선택적 공개를 지원하는 <a>검증가능한 크리덴셜</a>을 발급할 수 있다.
        </li>
        <li>
          단일 <a>검증가능한 크리덴셜</a>이 선택적 공개를 지원하는 경우 <a>보유자</a>는
          전체 <a>검증가능한 크리덴셜</a>을 공개하지 않고 <a>클레임</a>을 제시할 수 있다.
        </li>
        <li>
          <a>검증가능한 프레젠테이션</a>은 <a>검증가능한 크리덴셜</a>의 특성을 공개하거나
          <a>검증자</a>가 요청한 <a>파생된 조건자</a>를 충족할 수 있다. <a>파생된 조건자</a>는
          보다 큰, 보다 적은, 같음, 집합 등 부울 조건이다.
        </li>
        <li>
          <a>발급자</a>는 취소할 수 있는 <a>검증가능한 크리덴셜</a>을 발급할 수 있다.
        </li>
        <li>
          <a>검증가능한 크리덴셜</a> 및 <a>검증가능한 프레젠테이션</a>은 하나 이상의 기계 판독
          가능한 데이터 형식으로 직렬화할 수 있어야 한다. 직렬화 및/또는 직렬화 해제
          프로세스는 결정적이고 양방향이며 무손실이어야 한다. <a>검증가능한 크리덴셜</a> 또는
          <a>검증가능한 프레젠테이션</a>의 모든 직렬화는 최종 프로세스에서 이 문서에 정의된
          일반 데이터 모델로 변환할 수 있어야 하며, 따라서 <a>검증가능한 크리덴셜</a>을
          상호 운용 가능한 방식으로 처리할 수 있다. 또한 직렬화된 양식은 데이터 또는
          콘텐츠의 손실 없이 데이터 모델에서 생성될 수 있어야 한다.
        </li>
        <li>
          데이터 모델과 직렬화는 최소한의 조정으로 확장할 수 있어야 한다.
        </li>
        <li>
          <a>발급자</a>에 의한 폐기는 <a>주체</a>, <a>보유자</a>,
          특정 <a>검증가능한 크리덴셜</a> 또는 검증에 대한 식별 정보를 공개하지 않아야한다.
        </li>
        <li>
          <a>발급자</a>는 폐기 사유를 공개할 수 있다.
        </li>
        <li>
          <a>검증가능한 크리덴셜</a>을 해지하는 <a>발급자</a>는 암호화 무결성에 대한
          폐기(예: 서명 키가 손상된 경우)와 상태 변경에 대한
          폐기(예: 운전 면허증이 일시 중단됨)를 구분해야 한다.
        </li>
        <li>
          <a>발급자</a>는 <a>검증가능한 크리덴셜</a>을 갱신하는 서비스를 제공할 수 있다.
        </li>
      </ul>
    </section>

    <section id="conformance">Conformance</section>
    <p>
      This specification makes no normative statements with regard to the
      conformance of roles in the ecosystem, such as <a>issuers</a>, <a>holders</a>,
      or <a>verifiers</a>, because the conformance of ecosystem roles are highly
      application, use case, and market vertical specific.
    </p>

    <p>
      Digital proof mechanisms, a subset of which are digital signatures, are required
      to ensure the protection of a <a>verifiable credential</a>. Having and
      validating proofs, which may be dependent on the syntax of the proof
      (for example, using the JSON Web Signature of a JSON Web Token for proofing a
      key holder), are an essential part of processing a <a>verifiable credential</a>.
      At the time of publication, Working Group members had implemented
      <a>verifiable credentials</a> using at least three proof mechanisms:
    </p>

    <ul>
      <li>
        JSON Web Tokens [[RFC7519]] secured using JSON Web Signatures [[RFC7515]]
      </li>
      <li>
        Linked Data Signatures [[?LD-SIGNATURES]]
      </li>
      <li>
        Camenisch-Lysyanskaya Zero-Knowledge Proofs [[?CL-SIGNATURES]].
      </li>
    </ul>

    <p>
      Implementers are advised to note that not all proof mechanisms are standardized
      as of the publication date of this specification. The group expects some of
      these mechanisms, as well as new ones, to mature independently and become
      standardized in time. Given there are multiple valid proof mechanisms, this
      specification does not standardize on any single digital signature mechanism.
      One of the goals of this specification is to provide a data model that can be
      protected by a variety of current and future digital proof mechanisms.
      Conformance to this specification does not depend on the details of a particular
      proof mechanism; it requires clearly identifying the mechanism a
      <a>verifiable credential</a> uses.
    </p>

    <p>
      This document also contains examples that contain JSON and JSON-LD content.
      Some of these examples contain characters that are invalid JSON, such as
      inline comments (<code>//</code>) and the use of ellipsis (<code>...</code>)
      to denote information that adds little value to the example. Implementers are
      cautioned to remove this content if they desire to use the information as
      valid JSON or JSON-LD.
    </p>
  </section>

  </section>

  <section class="informative">
    <h2>Terminology</h2>

    <div data-include="./terms.html" data-oninclude="restrictReferences">
    </div>
  </section>

  <section class="informative">
    <h2>Core Data Model</h2>

    <p>
      The following sections outline core data model concepts, such as <a>claims</a>,
      <a>credentials</a>, and <a>presentations</a>, which form the foundation of this
      specification.
    </p>

    <section class="informative">
      <h3>Claims</h3>

      <p>
        A <a>claim</a> is a statement about a <a>subject</a>. A <a>subject</a> is
        a thing about which <a>claims</a> can be made. <a>Claims</a> are expressed using
        <strong><em>subject</em></strong>-<dfn data-lt="property|properties|속성|속성들">property</dfn>-<dfn>value</dfn>
        relationships.
      </p>

      <figure id="basic-structure">
        <img style="margin: auto; display: block; width: 50%;" src="diagrams/claim.svg" alt="subject has a property which
            has a value">
        <figcaption style="text-align: center;">
          The basic structure of a claim.
        </figcaption>
      </figure>

      <p>
        The data model for <a>claims</a>, illustrated in <a href="#basic-structure"></a>
        above, is powerful and can be used to express a large variety of statements. For
        example, whether someone graduated from a particular university can be expressed
        as shown in <a href="#basic-example"></a> below.
      </p>

      <figure id="basic-example">
        <img style="margin: auto; display: block; width: 60%;" src="diagrams/claim-example.svg" alt="Pat has an alumniOf
            property whose value is Example University">
        <figcaption style="text-align: center;">
          A basic claim expressing that Pat is an alumni of "Example University".
        </figcaption>
      </figure>

      <p>
        Individual <a>claims</a> can be merged together to express a <a>graph</a> of
        information about a <a>subject</a>. The example shown in
        <a href="#multiple-claims"></a> below extends the previous <a>claim</a> by
        adding the <a>claims</a> that Pat knows Sam and that Sam is employed as a
        professor.
      </p>

      <figure id="multiple-claims">
        <img style="margin: auto; display: block; width: 75%;" src="diagrams/claim-extended.svg" alt="extends previous
            diagram with another property called knows whose value is
            Sam, and Sam has a property jobTitle whose value is Professor">
        <figcaption style="text-align: center;">
          Multiple claims can be combined to express a graph of information.
        </figcaption>
      </figure>

      <p>
        To this point, the concepts of a <a>claim</a> and a <a>graph</a> of information
        are introduced. To be able to trust <a>claims</a>, more information is
        expected to be added to the graph.
      </p>
    </section>

    <section class="informative">
      <h3>Credentials</h3>

      <p>
        A <a>credential</a> is a set of one or more <a>claims</a> made by the same
        <a>entity</a>. <a>Credentials</a> might also include an identifier and
        metadata to describe properties of the <a>credential</a>, such as the
        <a>issuer</a>, the expiry date and time, a representative image, a public key
        to use for <a>verification</a> purposes, the revocation mechanism, and so on.
        The metadata might be signed by the <a>issuer</a>. A
        <a>verifiable credential</a> is a set of tamper-evident <a>claims</a> and
        metadata that cryptographically prove who issued it.
      </p>

      <figure id="basic-vc">
        <img style="margin: auto; display: block; width: 50%;" src="diagrams/credential.svg" alt="a Verifible
	       Credential contains Credential Metadata, Claim(s), and
	       Proof(s)">
        <figcaption style="text-align: center;">
          Basic components of a verifiable credential.
        </figcaption>
      </figure>

      <p>
        Examples of <a>verifiable credentials</a> include digital employee
        identification cards, digital birth certificates, and digital educational
        certificates.
      </p>

      <p class="note">
        <a>Credential</a> identifiers are often used to identify specific instances
        of a <a>credential</a>. These identifiers can also be used for correlation. A
        <a>holder</a> wanting to minimize correlation is advised to use a selective
        disclosure scheme that does not reveal the <a>credential</a> identifier.
      </p>

      <p>
        <a href="#basic-vc"></a> above shows the basic components of a
        <a>verifiable credential</a>, but abstracts the details about how <a>claims</a>
        are organized into information <a>graphs</a>, which are then organized into
        <a>verifiable credentials</a>. <a href="#info-graph-vc"></a> below shows a
        more complete depiction of a <a>verifiable credential</a>, which is normally
        composed of at least two information <a>graphs</a>. The first <a>graph</a>
        expresses the <a>verifiable credential</a> itself, which contains
        <span class="color-text" style="color:#d5a6bd;">credential metadata</span> and
        <span class="color-text" style="color:#ffe599;">claims</span>. The second
        <a>graph</a> expresses the
        <span class="color-text" style="color:#b6d7a8;">digital proof</span>, which is
        usually a digital signature.
      </p>

      <figure id="info-graph-vc">
        <img style="margin: auto; display: block; width: 100%;" src="diagrams/credential-graph.svg" alt="diagram with a
	       Credential Graph on top connected via a proof to a
	       Proof Graph on the bottom.  The Credental Graph has
	       Credential 123 with 4 properties: 'type' of value
	       AlumniCredential, 'issuer' of Example University,
	       'issuanceDate' of 2010-01-01T19:73:24Z, and
	       credentialSubject of Pat, who has an alumniOf property
	       with value of Example University.  The Proof Graph has
	       Signature 456 with 5 properties: 'type' of
	       RsaSignature2018, 'verificationMethod' of Example University
	       Public Key 7, 'created' of 2017-06-18T21:19:10Z, and 'jws'
         of 'BavEll0...3JT24='">
        <figcaption style="text-align: center;">
          Information graphs associated with a basic verifiable credential.
        </figcaption>
      </figure>

      <p class="note">
        It is possible to have a <a>credential</a>, such as a marriage certificate,
        containing multiple <a>claims</a> about different <a>subjects</a> that are not
        required to be related.
      </p>
      <p class="note">
        It is possible to have a <a>credential</a> that does not contain any
        <a>claims</a> about the <a>entity</a> to which the <a>credential</a> was issued.
        For example, a <a>credential</a> that only contains <a>claims</a> about a
        specific dog, but is issued to its owner.
      </p>
    </section>

    <section class="informative">
      <h3>Presentations</h3>

      <p>
        Enhancing privacy is a key design feature of this specification. Therefore, it
        is important for <a>entities</a> using this technology to be able to express
        only the portions of their persona that are appropriate for a given situation.
        The expression of a subset of one's persona is called a
        <a>verifiable presentation</a>. Examples of different personas include a
        person's professional persona, their online gaming persona, their
        family persona, or an incognito persona.
      </p>

      <p>
        A <a>verifiable presentation</a> expresses data from one or more
        <a>verifiable credentials</a>, and is packaged in such a way that the
        authorship of the data is <a>verifiable</a>. If <a>verifiable credentials</a>
        are presented directly, they become <a>verifiable presentations</a>. Data
        formats derived from <a>verifiable credentials</a> that are cryptographically
        <a>verifiable</a>, but do not of themselves contain
        <a>verifiable credentials</a>, might also be <a>verifiable presentations</a>.
      </p>

      <p>
        The data in a <a>presentation</a> is often about the same <a>subject</a>, but
        might have been issued by multiple <a>issuers</a>. The aggregation of this
        information typically expresses an aspect of a person, organization, or
        <a>entity</a>.
      </p>

      <figure id="basic-vp">
        <img style="margin: auto; display: block; width: 50%;" src="diagrams/presentation.svg" alt="A Verifiable
            Presentation contains Presentation Metadata, Verifiable
            Credential(s), and Proof(s)">
        <figcaption style="text-align: center;">
          Basic components of a verifiable presentation.
        </figcaption>
      </figure>

      <p>
        <a href="#basic-vp"></a> above shows the components of a
        <a>verifiable presentation</a>, but abstracts the details about how
        <a>verifiable credentials</a> are organized into information <a>graphs</a>,
        which are then organized into <a>verifiable presentations</a>.
        <a href="#info-graph-vp"></a> below shows a more complete depiction of a
        <a>verifiable presentation</a>, which is normally composed of at least four
        information <a>graphs</a>. The first <a>graph</a> expresses the
        <a>verifiable presentation</a> itself, which contains
        <span class="color-text" style="color:#b4a7d6;">presentation metadata</span>.
        The <code>verifiablePresentation</code> property in the <a>graph</a> refers to
        one or more <a>verifiable credentials</a> (each a self-contained <a>graph</a>),
        which in turn contains
        <span class="color-text" style="color:#d5a6bd;">credential metadata</span> and
        <span class="color-text" style="color:#ffe599;">claims</span>.
        The third <a>graph</a> expresses the
        <span class="color-text" style="color:#b6d7a8;">credential graph proof</span>,
        which is usually a digital signature. The fourth <a>graph</a> expresses the
        <span class="color-text" style="color:#a4c2f4;">presentation graph proof</span>,
        which is usually a digital signature.
      </p>

      <figure id="info-graph-vp">
        <img style="margin: auto; display: block; width: 75%;" src="diagrams/presentation-graph.svg" alt="diagram with
	       a Presentation Graph on top connected via a proof to a
	       Presentation Proof Graph on the bottom.  The
	       Presentation Graph has Presentation ABC with 3
	       properties: 'type' of value VerifiablePresentation,
	       'termsOfUse' of value Do Not Archive, and
	       'verifiableCredential' whose value is Figure 6.  The
	       Presentation Proof Graph has Signature 8910 with 5
	       properties: 'type' of RsaSignature2018, 'verificationMethod'
	       of Example Presenter Public Key 11, 'created' of
	       2018-01-15T12:43:56Z, 'challenge' of d28348djsj3239, and
	       'jws' of 'p2KaZ...8Fj3K='">
        <figcaption style="text-align: center;">
          Information graphs associated with a basic verifiable presentation.
        </figcaption>
      </figure>

      <p class="note">
        It is possible to have a <a>presentation</a>, such as a business persona, which
        draws on multiple <a>credentials</a> about different <a>subjects</a> that are
        often, but not required to be, related.
      </p>

    </section>

    <section class="informative">
      <h3>Concrete Lifecycle Example</h3>

      <p>
        The previous sections introduced the concepts of <a>claims</a>,
        <a>verifiable credentials</a>, and <a>verifiable presentations</a> using
        graphical depictions. This section provides a concrete set of simple but
        complete lifecycle examples of the data model expressed in one of the concrete
        syntaxes supported by this specification. The lifecycle of <a>credentials</a>
        and <a>presentations</a> in the
        <a href="#ecosystem-overview">Verifiable Credentials Ecosystem</a> often
        take a common path:
      </p>

      <ol>
        <li>
          Issuance of one or more <a>verifiable credentials</a>.
        </li>
        <li>
          Storage of <a>verifiable credentials</a> in a <a>credential repository</a>
          (such as a digital wallet).
        </li>
        <li>
          Composition of <a>verifiable credentials</a> into a
          <a>verifiable presentation</a> for <a>verifiers</a>.
        </li>
        <li>
          <a>Verification</a> of the <a>verifiable presentation</a> by the
          <a>verifier</a>.
        </li>
      </ol>

      <p>
        To illustrate this lifecycle, we will use the example of redeeming an alumni
        discount from a university. In the example below, Pat receives an alumni
        <a>verifiable credential</a> from a university, and Pat stores the
        <a>verifiable credential</a> in a digital wallet.
      </p>

      <pre class="example nohighlight" title="A simple example of a verifiable credential">
{
  <span class='comment'>// set the context, which establishes the special terms we will be using
  // such as 'issuer' and 'alumniOf'.</span>
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  <span class='comment'>// specify the identifier for the credential</span>
  "id": "http://example.edu/credentials/1872",
  <span class='comment'>// the credential types, which declare what data to expect in the credential</span>
  "type": ["VerifiableCredential", "AlumniCredential"],
  <span class='comment'>// the entity that issued the credential</span>
  "issuer": "https://example.edu/issuers/565049",
  <span class='comment'>// when the credential was issued</span>
  "issuanceDate": "2010-01-01T19:73:24Z",
  <span class='comment'>// claims about the subjects of the credential</span>
  "credentialSubject": {
    <span class='comment'>// identifier for the only subject of the credential</span>
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    <span class='comment'>// assertion about the only subject of the credential</span>
    "alumniOf": {
      "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
      "name": [{
        "value": "Example University",
        "lang": "en"
      }, {
        "value": "Exemple d'Université",
        "lang": "fr"
      }]
    }
  },
  <span class='comment'>// digital proof that makes the credential tamper-evident</span>
  <span class='comment'>// see the NOTE at end of this section for more detail</span>
  "proof": {
    <span class='comment'>// the cryptographic signature suite that was used to generate the signature</span>
    "type": "RsaSignature2018",
    <span class='comment'>// the date the signature was created</span>
    "created": "2017-06-18T21:19:10Z",
    <span class='comment'>// purpose of this proof</span>
    "proofPurpose": "assertionMethod",
    <span class='comment'>// the identifier of the public key that can verify the signature</span>
    "verificationMethod": "https://example.edu/issuers/keys/1",
    <span class='comment'>// the digital signature value</span>
    "jws": "eyJhbGciOiJSUzI1NiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..TCYt5X
      sITJX1CxPCT8yAV-TVkIEq_PbChOMqsLfRoPsnsgw5WEuts01mq-pQy7UJiN5mgRxD-WUc
      X16dUEMGlv50aqzpqh4Qktb3rk-BuQy72IFLOqV0G_zS245-kronKb78cPN25DGlcTwLtj
      PAYuNzVBAh4vGHSrQyHUdBBPM"
  }
}
        </pre>

      <p>
        Pat then attempts to redeem the alumni discount. The <a>verifier</a>, a ticket
        sales system, states that any alumni of "Example University" receives a discount
        on season tickets to sporting events. Using a mobile device, Pat starts the
        process of purchasing a season ticket. A step in this process requests an alumni
        <a>verifiable credential</a>, and this request is routed to Pat's digital wallet.
        The digital wallet asks Pat if they would like to provide a previously issued
        <a>verifiable credential</a>. Pat selects the alumni
        <a>verifiable credential</a>, which is then composed into a
        <a>verifiable presentation</a>. The <a>verifiable presentation</a> is sent to
        the <a>verifier</a> and <a>verified</a>.
      </p>
      <pre class="example nohighlight" title="A simple example of a verifiable presentation">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "type": "VerifiablePresentation",
  <span class='comment'>// the verifiable credential issued in the previous example</span>
  "verifiableCredential": [{
    "@context": [
      "https://www.w3.org/2018/credentials/v1",
      "https://www.w3.org/2018/credentials/examples/v1"
    ],
    "id": "http://example.edu/credentials/1872",
    "type": ["VerifiableCredential", "AlumniCredential"],
    "issuer": "https://example.edu/issuers/565049",
    "issuanceDate": "2010-01-01T19:73:24Z",
    "credentialSubject": {
      "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
      "alumniOf": {
        "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
        "name": [{
          "value": "Example University",
          "lang": "en"
        }, {
          "value": "Exemple d'Université",
          "lang": "fr"
        }]
      }
    },
    "proof": {
      "type": "RsaSignature2018",
      "created": "2017-06-18T21:19:10Z",
      "proofPurpose": "assertionMethod",
      "verificationMethod": "https://example.edu/issuers/keys/1",
      "jws": "eyJhbGciOiJSUzI1NiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..TCYt5X
        sITJX1CxPCT8yAV-TVkIEq_PbChOMqsLfRoPsnsgw5WEuts01mq-pQy7UJiN5mgRxD-WUc
        X16dUEMGlv50aqzpqh4Qktb3rk-BuQy72IFLOqV0G_zS245-kronKb78cPN25DGlcTwLtj
        PAYuNzVBAh4vGHSrQyHUdBBPM"
    }
  }],
  <span class='comment'>// digital signature by Pat on the presentation
  // protects against replay attacks</span>
  "proof": {
    "type": "RsaSignature2018",
    "created": "2018-09-14T21:19:10Z",
    "proofPurpose": "authentication",
    "verificationMethod": "did:example:ebfeb1f712ebc6f1c276e12ec21#keys-1",
    <span class='comment'>// 'challenge' and 'domain' protect against replay attacks</span>
    "challenge": "1f44d55f-f161-4938-a659-f8026467f126",
    "domain": "4jt78h47fh47",
    "jws": "eyJhbGciOiJSUzI1NiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..kTCYt5
      XsITJX1CxPCT8yAV-TVIw5WEuts01mq-pQy7UJiN5mgREEMGlv50aqzpqh4Qq_PbChOMqs
      LfRoPsnsgxD-WUcX16dUOqV0G_zS245-kronKb78cPktb3rk-BuQy72IFLN25DYuNzVBAh
      4vGHSrQyHUGlcTwLtjPAnKb78"
  }
}
        </pre>

      <p class="note">
        Implementers that are interested in understanding more about the
        <code>proof</code> mechanism used above can learn more in
        Section <a href="#proofs-signatures"></a> and by reading the
        following specifications: Linked Data Proofs [[LD-PROOFS]], Linked Data
        Signatures [[LD-SIGNATURES]], 2018 RSA Signature Suite [[LDS-RSA2018]], and
        JSON Web Signature (JWS) Unencoded Payload Option [[RFC7797]]. A list
        of proof mechanisms is available in the Verifiable Credentials
        Extension Registry [[VC-EXTENSION-REGISTRY]].
      </p>
    </section>
  </section>

  <section class="normative">
    <h2>Basic Concepts</h2>

    <p>
      This section introduces some basic concepts for the specification, in
      preparation for Section <a href="#advanced-concepts"></a> later in the
      document.
    </p>

    <section>
      <h3>Contexts</h3>

      <p>
        When two software systems need to exchange data, they need to use terminology
        that both systems understand. As an analogy, consider how two people
        communicate. Both people must use the same language and the words they use must
        mean the same thing to each other. This might be referred to as
        <em>the context of a conversation</em>.
      </p>
      <p>
        <a>Verifiable credentials</a> and <a>verifiable presentations</a> have many
        attributes and values that are identified by <a>URIs</a>. However, those
        <a>URIs</a> can be long and not very human-friendly. In such cases, short-form
        human-friendly aliases can be more helpful. This specification uses the
        <code>@context</code> <a>property</a> to map such short-form aliases to the URIs
        required by specific <a>verifiable credentials</a> and
        <a>verifiable presentations</a>.
      </p>
      <p class="note">
        In JSON-LD, the <code>@context</code> <a>property</a> can also be used to
        communicate other details, such as datatype information, language information,
        transformation rules, and so on, which are beyond the needs of this
        specification, but might be useful in the future or to related work. For more
        information, see
        <a href="https://www.w3.org/TR/json-ld11/#the-context">Section 3.1: The Context</a>
        of the [[JSON-LD]] specification.
      </p>
      <p>
        <a>Verifiable credentials</a> and <a>verifiable presentations</a> MUST include a
        <code>@context</code> <a>property</a>.
      </p>

      <dl>
        <dt><dfn>@context</dfn></dt>
        <dd>
          The value of the <code>@context</code> <a>property</a> MUST be an ordered set
          where the first item is a <a>URI</a> with the value
          <code>https://www.w3.org/2018/credentials/v1</code>. For reference, a copy of
          the base context is provided in Appendix <a href="#base-context"></a>.
          Subsequent items in the array MUST express context information and be composed
          of any combination of <a>URIs</a> or objects. It is RECOMMENDED that each
          <a>URI</a> in the <code>@context</code> be one which, if dereferenced, results
          in a document containing machine-readable information about the
          <code>@context</code>.
        </dd>
      </dl>
      <p class="note">
        Though this specification requires that a <code>@context</code> <a>property</a>
        be present, it is not required that the value of the <code>@context</code>
        <a>property</a> be processed using JSON-LD. This is to support processing using
        plain JSON libraries, such as those that might be used when the
        <a>verifiable credential</a> is encoded as a JWT. All libraries or processors
        MUST ensure that the order of the values in the <code>@context</code>
        <a>property</a> is what is expected for the specific application. Libraries or
        processors that support JSON-LD can process the <code>@context</code>
        <a>property</a> using full JSON-LD processing as expected.
      </p>
      <pre class="example nohighlight" title="Usage of the @context property">
{
  <span class="highlight">"@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ]</span>,
  "id": "http://example.edu/credentials/58473",
  "type": ["VerifiableCredential", "AlumniCredential"],
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "alumniOf": {
      "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
      "name": [{
        "value": "Example University",
        "lang": "en"
      }, {
        "value": "Exemple d'Université",
        "lang": "fr"
      }]
    }
  },
  "proof": { <span class="comment">...</span> }
}
        </pre>

      <p>
        The example above uses the base context <a>URI</a>
        (<code>https://www.w3.org/2018/credentials/v1</code>) to establish that the
        conversation is about a <a>verifiable credential</a>. The second <a>URI</a>
        (<code>https://www.w3.org/2018/credentials/examples/v1</code>) establishes that
        the conversation is about examples.
      </p>

      <p class="note">
        This document uses the example context <a>URI</a>
        (<code>https://www.w3.org/2018/credentials/examples/v1</code>) for the purpose
        of demonstrating examples. Implementations are expected to not use this
        <a>URI</a> for any other purpose, such as in pilot or production systems.
      </p>

      <p>
        The data available at <code>https://www.w3.org/2018/credentials/v1</code> is a
        static document that is never updated and SHOULD be downloaded and cached. The
        associated human-readable vocabulary document for the Verifiable Credentials
        Data Model is available at
        <a href="https://www.w3.org/2018/credentials">https://www.w3.org/2018/credentials</a>.
        This concept is further expanded on in Section <a href="#extensibility"></a>.
      </p>

    </section>

    <section id="identifiers">
      <h3>식별자</h3>

      <p>
        사람, 제품, 또는 조직과 같은 특정한 것에 대해 표현할때,
        다른 사람들이 동일한 것을 표현할 수 있도록 식별자를 사용하는 것이 유용하다.
        이 규격에서는 이러한 식별자들에 대한 선택적 <code>id</code> 속성을 정의한다.
        <code>id</code> <a>속성</a>은 사람, 제품 또는 조직과 같은 객체를 명확하게 참조하기 위한 것이다.
        <code>id</code> <a>속성</a>을 사용하면
        <a>검증가능한 크리덴셜</a>을 통해 특정한 사물을 표현할 수 있게 된다.
      </p>

      <p>
        <em>만약</em> <code>id</code> <a>속성</a>이 존재한다면:
      </p>

      <ul>
        <li>
          <code>id</code> <a>속성</a>을 표현할 때 반드시 다른 사용자들이 특정 사물을 표현할 때 사용할 것으로 예상되는 식별자로 표현해야 한다.
        </li>
        <li>
          <code>id</code> <a>속성</a>은 반드시 하나의 값만 가져야 한다.
        </li>
        <li>
          <code>id</code> <a>속성</a>의 값은 반드시 URI 이어야 한다
        </li>
      </ul>

      <p class="note">
        개발자들은 익명성이 요구되는 시나리오에서 식별자가 유해할 수 있다는 것을 기억해야 한다.
        그러한 시나리오를 고려할 때 <a href="#identifier-based-correlation"></a> 부분을 주의깊게 읽을 것을 권장한다.
        프라이버시 문제를 만들어 내는 다른 유형의 연관메커니즘문서도
        <a href="#privacy-considerations"></a>에서 다룬다.
        프라이버시가 중요한 고려사항인 경우 <code>id</code> <a>속성</a>은 생략 될 수 있다.
      </p>

      <dl>
        <dt><dfn>id</dfn></dt>
        <dd>
          <code>id</code> <a>속성</a> 값은 반드시 단일 <a>URI</a>여야 한다.
          역참조되는 경우 <a>URI</a>는 <code>id</code>에 대한
          기계판독가능정보를 포함한 문서를 생성하는 것이 권장된다.
        </dd>
      </dl>

      <pre class="example nohighlight" title="Usage of the id property">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  <span class="highlight">"id": "http://example.edu/credentials/3732"</span>,
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  "credentialSubject": {
    <span class="highlight">"id": "did:example:ebfeb1f712ebc6f1c276e12ec21"</span>,
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  "proof": { <span class="comment">...</span> }
}
        </pre>

      <p>
        위의 예는 두 가지 유형의 식별자를 사용한다.
        첫 번째는 <a>검증가능한 크리덴셜</a>을 위한 것이며 HTTP 기반 URL을 사용한다.
        두 번째는 <a>검증가능한 크리덴셜</a>의 <a>주체</a>(<a>클레임</a>이 관련된 것)를 위한 것이며
        <a>DID</a>라고도하는 <a>탈중앙 식별자</a>를 사용한다.
      </p>

      <p class="note">
        본 간행물에 의하면, <a>DIDs</a>는 새로운 유형의 식별자이지만
        <a>검증가능한 크리덴셜</a>의 유용성에 필수는 아니다.
        구체적으로 <a>검증가능한 크리덴셜</a>은 <a>DIDs</a>에 의존하지 않으며,
        <a>DIDs</a>는 <a>검증가능한 크리덴셜</a>에 의존하지 않는다.
        그렇지만 많은 <a>검증가능한 크리덴셜</a>이 <a>DIDs</a>를 사용할 것으로 예상되고,
        이 규격을 구현하는 소프트웨어 라이브러리는 <a>DIDs</a>를 구현할 필요가 있을 것이다.
        <a>DID</a> 기반 URL은 <a>주체</a>, <a>발급자</a>, <a>보유자</a>, 크리덴셜 상태 목록, 암호화 키
        그리고 <a>검증가능한 크리덴셜</a>과 관련된 기계 판독 가능 정보를 관련된 식별자로 표현하는 데 사용된다.
      </p>
    </section>

    <section id="types">
      <h3>타입</h3>

      <p>
        이 문서에 지정된 객체들을 처리하는 소프트웨어 시스템은 제공된
        <a>검증가능한 크리덴셜</a> 또는 <a>검증가능한 프레젠테이션</a>이 적절한지 여부를 결정하기 위해
        <code>type</code>정보를 사용한다.
        이 규격은 타입 정보 표현에 대한 <code>type</code><a>속성</a>을 정의한다.
      </p>

      <p>
        <a>검증가능한 크리덴셜</a>과 <a>검증가능한 프레젠테이션</a>에는
        반드시 <code>type</code><a>속성</a>이 있어야 한다.
        따라서 <code>type</code><a>속성</a>이 없는 <a>크리덴셜</a>, 또는 <a>프레젠테이션</a>은
        <a>검증</a>을 할수 없으므로 <a>검증가능한 크리덴셜</a>이나 <a>검증가능한 프레젠테이션</a>이 아니다.
      </p>

      <dl>
        <dt><dfn data-lt="type|types|타입">type</dfn></dt>
        <dd>
          <code>type</code><a>속성</a>의 값은 반드시 맵핑된(<code>@context</code> 속성의 해석을 통해),
          하나 또는 이상의 <a>URIs</a>다.
          만약 복수의 <a>URI</a>들이 제공되었다면, <a>URIs</a>는 순서가 없는 집합으로 해석해야 한다.
          개발편의를 위해 문법적 편의성을 반드시 사용해야 한다.
          이러한 편의성에는 JSON-LD 용어가 포함될 수 있다.
          <code>type</code>의 각 <a>URI</a>가 역참조되는 경우
          <code>type</code>에 대한 기계판독가능정보가 포함된 문서를 생성하는 것이 권장된다.
        </dd>
      </dl>

      <pre class="example nohighlight" title="Usage of the type property">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  <span class="highlight">"type": ["VerifiableCredential", "UniversityDegreeCredential"]</span>,
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  "proof": { <span class="comment">...</span> }
}
        </pre>

      <p>
        규격준수와 관련하여, 다음 표에는 객체들이 반드시 가져야 하는 <a>타입</a>이 명시되어 있다
      </p>

      <table class="simple">
        <thead>
          <tr>
            <th>Object</th>
            <th>Type</th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td>
              <a>Verifiable credential</a>&nbsp;object <br />(a subclass of a
              <a href="#credentials">credential</a>&nbsp;object)
            </td>
            <td>
              <code>VerifiableCredential</code> and, optionally, a more specific
              <a>verifiable credential</a> <a>type</a>. For example,<br>
              <code>"type": ["VerifiableCredential", "UniversityDegreeCredential"]</code>
            </td>
          </tr>

          <tr>
            <td>
              <a href="#credentials">Credential</a>&nbsp;object
            </td>
            <td>
              <code>VerifiableCredential</code> and, optionally, a more specific
              <a>verifiable credential</a> <a>type</a>. For example,<br>
              <code>"type": ["VerifiableCredential", "UniversityDegreeCredential"]</code>
            </td>
          </tr>

          <tr>
            <td>
              <a>Verifiable presentation</a>&nbsp;object <br />(a subclass of a
              <a href="#presentations">presentation</a>&nbsp;object)
            </td>
            <td>
              <code>VerifiablePresentation</code> and, optionally, a more specific
              <a>verifiable presentation</a> <a>type</a>. For example,<br>
              <code>"type": ["VerifiablePresentation", "CredentialManagerPresentation"]</code>
            </td>
          </tr>

          <tr>
            <td>
              <a href="#presentations">Presentation</a>&nbsp;object
            </td>
            <td>
              <code>VerifiablePresentation</code> and, optionally, a more specific
              <a>verifiable presentation</a> <a>type</a>. For example,<br>
              <code>"type": ["VerifiablePresentation", "CredentialManagerPresentation"]</code>
            </td>
          </tr>

          <tr>
            <td>
              <a href="#proofs-signatures">Proof</a>&nbsp;object
            </td>
            <td>
              A valid proof <a>type</a>. For example,<br>
              <code>"type": "RsaSignature2018"</code>
            </td>
          </tr>

          <tr>
            <td>
              <a href="#status">credentialStatus</a>&nbsp;object
            </td>
            <td>
              A valid <a>credential</a> status <a>type</a>. For example,<br>
              <code>"type": "CredentialStatusList2017"</code>
            </td>
          </tr>

          <tr>
            <td>
              <a href="#terms-of-use">termsOfUse</a>&nbsp;object
            </td>
            <td>
              A valid terms of use <a>type</a>. For example,<br>
              <code>"type": "OdrlPolicy2017"</code>)
            </td>
          </tr>

          <tr>
            <td>
              <a href="#evidence">evidence</a>&nbsp;object
            </td>
            <td>
              A valid evidence <a>type</a>. For example,<br>
              <code>"type": "DocumentVerification2018"</code>
            </td>
          </tr>

        </tbody>
      </table>

      <p class="note">
        검증가능한 크리덴셜 데이터 모델의 <a>타입</a>시스템은 [[JSON-LD]]와 동일하며
        <a href="https://www.w3.org/TR/json-ld/#specifying-the-type">섹션 5.4:
          Specifying the Type</a> 그리고 <a href="https://www.w3.org/TR/json-ld/#json-ld-grammar">섹션 8: JSON-LD
          Grammar</a>에 자세히 설명되어 있다. JSON-LD 컨텍스트를 사용할 때 (
        <a href="#extensibility"></a> 참조),
        이 규격의 <code>@type</code> 키워드를 다른 이름인 <code>type</code>으로 바꾸면
        JSON-LD 문서의 이해가 쉬워질 것이다.
        애플리케이션 개발자와 문서 작성자는 JSON-LD 타입 시스템의 세부사항을 이해할 필요는 없지만,
        상호운용 가능한 확장성을 지원하려는 이 규격의 구현자들은 그 내용을 이해해야 한다.
      </p>

      <p>
        모든 <a>크리덴셜</a>, <a>프레젠테이션</a>, 그리고 캡슐화된 객채들은 추가정보를 처리할 수 있도록,
        더욱 제한된 <a>타입</a>들(예를 들어 <code>UniversityDegreeCredential</code>과 같은)을
        반드시 명시하거나 연관시켜야 한다.
      </p>

      <p>
        이 규격에 정의된 캡슐화된 객체
        (예를 들어 <code>credentialSubject</code>객체와 관련되거나 깊이 중첩된 객체들)들을 처리할 때,
        소프트웨어 시스템은 객체를 캡슐화할때 사용된 상위 계층의<a>타입</a> 정보를 사용해야 한다.
        구체적으로 <a>크리덴셜</a>과 같은 캡슐화된 객체들은 연관된 객체 <a>타입</a>을 전달하여,
        <a>검증자</a>가 캡슐화 객체의 <a>타입</a>에 기초하여 관련 객체의 내용을 신속하게 파악할 수 있어야한다.
      </p>

      <p>
        예를 들어, <code>UniversityDegreeCredential</code>과 같은 <code>type</code>의 <a>크리덴셜</a> 객체는
        다음 항목을 위한 식별자가 <code>credentialSubject</code> 속성에 포함되어 있다는 것을
        <a>검증자</a>에게 전송한다:
      </p>

      <ul>
        <li>
          <code>id</code> 속성이 가지고 있는 <a>주체</a>
        </li>
        <li>
          <code>type</code> 속성이 가지고 있는 학위 형식
        </li>
        <li>
          <code>name</code> 속성이 가지고 있는 학위 타이틀
        </li>
      </ul>

      <p>
        이를 통해 구현자는 <a>검증</a>을 목적으로 <code>type</code> 속성과 관련된 값에 의존할 수 있다.
        <a>타입</a> 및 관련 속성은 최소한 사람이 읽을 수 있는 규격으로 문서화하는 것과 함께,
        가급적 기계판독가능한 설명을 추가해야 한다.
      </p>

      <p class="note">
        이 규격에 기술된 데이터 모델에 사용되는 타입 시스템은 타입과 데이터를 연결하는 여러가지 방법을 허용한다.
        구현자와 작성자는 검증가능한 크리덴셜 구현 가이드[[?VC-IMP-GUIDE]]의 타이핑에 관한 섹션을 읽어야 한다.
      </p>
    </section>

    <section id="credential-subject">
      <h3>자격 주체</h3>

      <p>
        <a>검증가능한 크리덴셜</a> 에는 하나 이상의 <a>주체들</a>에 대한 <a>클레임</a>이 포함된다.
        이 규격은 하나 이상의 <a>주체들</a>에 대한 <a>클레임</a>을 표현하기 위한 항목인
        <code>credentialSubject</code>
        <a>속성</a>을 정의한다.
      </p>

      <p>
        <a>검증가능한 크리덴셜</a>에는 무조건 <code>credentialSubject</code> <a>속성</a>이 있어야 한다.
      </p>

      <dl>
        <dt>credentialSubject</dt>
        <dd>
          The value of the <code>credentialSubject</code> <a>property</a> is defined as
          <code>credentialSubject</code> <a>속성</a>의 값은 <a>검증가능한 크리덴셜</a>의 <a>주체</a>와
          각각 관련된 하나 이상의 특성을 포함하는
          객체 세트로 정의된다. <a href="#identifiers"></a>에 설명 된대로 각 객체에는 <code>id</code>가 포함될 수도 있다.

        </dd>
      </dl>

      <pre class="example nohighlight" title="credentialSubject 속성 사용">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  <span class="highlight">"credentialSubject"</span>: {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  "proof": { <span class="comment">...</span> }
}
        </pre>

      <p>
        <a>검증가능한 크리덴셜</a>로 여러 <a>주체</a>와 관련된 정보를 표현할 수 있다.
        아래의 예는 배우자 관계인 두 <a>주체</a>를 지정한다.
        여러 <a>주체</a>를 <code>credentialSubject</code> 특성과 연관시키기 위해 배열 표기법을 사용한다.
      </p>

      <pre class="example nohighlight" title="검증가능한 크리덴셜로 여러 주체 지정">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "RelationshipCredential"],
  "credentialSubject": <span class="highlight">[{
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "name": "Jayden Doe",
    "spouse": "did:example:c276e12ec21ebfeb1f712ebc6f1"
  }, {
    "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
    "name": "Morgan Doe",
    "spouse": "did:example:ebfeb1f712ebc6f1c276e12ec21"
  }]</span>,
  "proof": { <span class="comment">...</span> }
}
        </pre>

    </section>

    <section id="issuer">
      <h3>발급자</h3>

      <p>
        이 규격은 <a>검증가능한 크리덴셜</a>의 <a>발급자</a>를 표현하기 위한 속성을 정의한다.
      </p>

      <p>
        <a>검증가능한 크리덴셜</a>은 무조건 <code>issuer</code> <a>속성</a>이 있어야 한다.
      </p>

      <dl>
        <dt><var>issuer</var></dt>
        <dd>
          <code>issuer</code> <a>속성</a> 값은 무조건 <a>URI</a>이거나 <code>id</code> <a>속성</a>을 포함하는 객체여야한다.
          <code>issuer</code> 또는 해당 <code>id</code>의 <a>URI</a>는 역 참조 된 경우
          <a>크리덴셜</a>에 표시된 정보를 <a>검증</a>하는 데 사용할 수 있는
          <a>issuer</a>에 대한 기계판독 가능한 정보를 포함하는 문서를 생성하는 URI 여야 한다.
        </dd>
      </dl>

      <pre class="example nohighlight" title="발급자 특성의 사용">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  <span class="highlight">"issuer": "https://example.edu/issuers/14"</span>,
  "issuanceDate": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  "proof": { <span class="comment">...</span> }
}
        </pre>

      <p>
        객체를 발급자 특성과 연관시켜 발급자에 대한 추가 정보를 표현 할 수도 있다.
      </p>

      <pre class="example nohighlight" title="발급자 확장형 특성 사용">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  <span class="highlight">"issuer": {
    "id": "did:example:76e12ec712ebc6f1c221ebfeb1f",
    "name": "Example University"
  }</span>,
  "issuanceDate": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  "proof": { <span class="comment">...</span> }
}
        </pre>

      <p class="note">
        <code>issuer</code> <a>속성</a>값은 JWK (예를 들어, <code>"https://example.com/keys/foo.jwk"</code>)
        또는 a <a>DID</a> (예를 들어, <code>"did:example:abfe13f712120431c276e12ecab"</code>)이 될 수 있다.
      </p>

    </section>

    <section id="issuance-date">
      <h3>발급 날짜</h3>

      <p>
        이 규격은 <a>크리덴셜</a>이 유효한 날짜 및 시간을 표현하기 위한 <code>issuanceDate</code> <a>속성</a>을 정의한다.
      </p>

      <dl>
        <dt><var>issuanceDate</var></dt>
        <dd>
          <a>크리덴셜</a>은 무조건 <code>issuanceDate</code> <a>속성</a>을 가져야 한다.
          <code>issuanceDate</code> <a>속성</a>의 값은
          <a>크리덴셜</a>이 유효한 날짜와 시간을 나타내는 [[!RFC3339]] 결합 날짜 및 시간
          문자열의 문자열 값이어야하며 이는 미래의 날짜와 시간 일 수 있다. 이 값은 <code>credentialSubject</code>
          <a>속성</a>과 연관된 정보가 유효 해지는 가장 빠른 시점을 나타낸다.

        </dd>
      </dl>

      <pre class="example nohighlight" title="issuanceDate 속성 사용">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  "issuer": "https://example.edu/issuers/14",
  <span class="highlight">"issuanceDate": "2010-01-01T19:23:24Z"</span>,
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  "proof": { <span class="comment">...</span> }
}
        </pre>

      <p class="note">
        이 스펙의 다음 버전은 <code>validFrom</code> <a>속성</a>을 추가하고
        새로운 <code>issued</code> 된 <a>속성</a>을 위해 <code>issuanceDate</code> <a>속성</a>을
        더 이상 사용하지 않을 것으로 예상된다. 두 속성의 값 범위는 [[?RFC3339]] 결합 날짜 및 시간 문자열로 유지
        될 것으로 예상한다. 구현자는 <code>validFrom</code> 및 <code>issued</code> <a>속성</a>을 예약하고
        다른 목적으로 사용하지 않는 것이 좋다.
      </p>

    </section>

    <section id="proofs-signatures">
      <h3>프루프들 (시그니쳐들)</h3>

      <p>
        <a>크리덴셜</a> 또는 <a>프레젠테이션</a>이 <a>검증가능한 크리덴셜</a> 또는 <a>검증가능한 프레젠테이션</a>이 되도록 최소한 하나의 증명 메커니즘과
        그 증거를 평가하는데 필요한 세부 사항을 표현해야 한다. 즉, <a>검증</a> 할 수 있어야 한다.

      </p>

      <p>
        이 규격은 두가지 종류의 메커니즘을 식별한다: 외부 증명과 내장된 증명.
        <dfn>외부 프루프</dfn>은 <a href="#json-web-token"></a>섹션에 자세히
        설명되어 있는 JSON 웹 토큰과 같은 데이터 모델의 표현을 감싸는 것이다.<dfn>내장 된 프루프</dfn>는 <a href="#linked-data-proofs"></a>
        섹션에 자세히 설명된 linked data signature과 같은 데이터에 증명이 포함되는 메커니즘이다.

      </p>

      <p>
        프루프을 포함 할 때는 <code>proof</code> <a>속성</a>을 무조건 사용해야 한다.

      </p>

      <dl>
        <dt><var>proof</var></dt>
        <dd>
          변조를 감지하고 <a>크리덴셜</a> 또는 <a>프레젠테이션</a>의 소유권을 확인하는 데 사용할 수 있는 하나
          이상의 암호화 프루프이다. <a>내장 된 프루프</a>에 사용되는 특정 방법은 무조건 <code>type</code> <a>속성</a>을 사용하여 포함해야한다.

        </dd>
      </dl>

      <p>
        수학적 증명에 사용되는 방법은 표현 언어와 사용 된 기술에 따라 다르므로 <code>proof</code> <a>속성</a>의 값으로 예상되는
        이름-값 쌍 세트는 그에 따라 달라진다. 예를 들어, 프루프 메커니즘에 디지털 서명이 사용되는 경우 <code>proof</code>
        <a>속성</a>에는 서명, 서명 엔터티에 대한 참조 및 서명 날짜 표시가 포함 된 이름-값 쌍이 있어야한다. 아래 예는 RSA
        디지털 서명을 사용한다.
      </p>

      <pre class="example nohighlight" title="검증가능한 크리덴셜에 프루프 속성 사용">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.gov/credentials/3732",
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  "issuer": "https://example.edu",
  "issuanceDate": "2010-01-01T19:73:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"proof": {
    "type": "RsaSignature2018",
    "created": "2018-06-18T21:19:10Z",
    "proofPurpose": "assertionMethod",
    "verificationMethod": "https://example.com/jdoe/keys/1",
    "jws": "eyJhbGciOiJQUzI1NiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19
      ..DJBMvvFAIC00nSGB6Tn0XKbbF9XrsaJZREWvR2aONYTQQxnyXirtXnlewJMB
      Bn2h9hfcGZrvnC1b6PgWmukzFJ1IiH1dWgnDIS81BH-IxXnPkbuYDeySorc4
      QU9MJxdVkY5EL4HYbcIfwKj6X4LBQ2_ZHZIu1jdqLcRZqHcsDF5KKylKc1TH
      n5VRWy5WhYg_gBnyWny8E6Qkrze53MR7OuAmmNJ1m1nN8SxDrG6a08L78J0-
      Fbas5OjAQz3c17GY8mVuDPOBIOVjMEghBlgl3nOi1ysxbRGhHLEK4s0KKbeR
      ogZdgt1DkQxDFxxn41QWDw_mmMCjs9qxg0zcZzqEJw"
  }</span>
}
        </pre>

      <p class="note">
        <a href="#conformance"></a>에서 논의 된 바와 같이, 여러 가지 가능한 증명 메커니즘이 있으며,
        이 사양은 <a>검증가능한 크리덴셜</a>과 함께 사용하기위한 단일 증명 메커니즘을 표준화하거나 권장하지 않는다.
        <code>proof</code> 메커니즘에 대한 자세한 내용은 다음 사양을 참조하시오. Linked Data Proofs [[LD-PROOFS]],
        Linked Data Signatures [[LD-SIGNATURES]], 2018 RSA Signature Suite [[LDS-RSA2018]] 및 JSON Web Signature(JWS)
        Unencoded Payload Option [[RFC7797]]. 프루프메커니즘 목록은 Verifiable Credentials Extension Registry
        [[VC-EXTENSION-REGISTRY]]에서 찾을 수 있다.
      </p>

    </section>

    <section id="expiration">
      <h3>만료</h3>

      <p>
        이 사양에서는 <a>크리덴셜</a> 만료 정보 표현을위한 <code>expirationDate</code> <a>속성</a>을 정의한다.

      </p>

      <dl>
        <dt><var>expirationDate</var></dt>
        <dd>
          존재하는 경우, <code>expirationDate</code> <a>속성</a>의 값은 무조건 <a>크리덴셜</a>이 유효하지 않은 날짜와 시간을
          나타내는 [[!RFC3339]] 결합 날짜 및 시간 문자열의 문자열 값이어야 한다.
        </dd>
      </dl>

      <pre class="example nohighlight" title="expirationDate 속성의 이용">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  "issuer": "https://example.edu/issuers/14",
  "issuanceDate": "2010-01-01T19:23:24Z",
  <span class="highlight">"expirationDate": "2020-01-01T19:23:24Z"</span>,
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  "proof": { <span class="comment">...</span> }
}
        </pre>

      <p class="note">
        이 규격의 다음 버전에서는 사용되지 않는 방식으로 <code>validUntil</code> <a>속성</a>을 추가하지만 <code>expirationDate</code>
        <a>속성</a>과의 호환성을 유지해야한다.
        구현자는 <code>validUntil</code> <a>속성</a>이 이미 용도결정이 되어 있고
        다른 용도로 사용하지 않는 것이 좋다.
      </p>

    </section>

    <section id="status">
      <h3>상태</h3>

      <p>
        이 규격은 <a>검증가능한 크리덴셜</a>의 현재 상태(예를들어 일시중지 또는 취소)에 대한 정보를 검색하기 위해
        다음 <code>credentialStatus</code><a>속성</a>을 정의한다.
      </p>

      <dl>
        <dt><var>credentialStatus</var></dt>
        <dd>
          <code>credentialStatus</code> <a>속성</a>의 값은 무조건 다음 사항들을 포함해야 한다.
          <ul>
            <li>
              <code>id</code> <a>속성</a>은 무조건 URL이여야 한다.
            </li>
            <li>
              <code>type</code> <a>속성</a>은 <a>크리덴셜</a> 상태 유형(<a>크리덴셜</a> 상태 메소드라고도 함)을 나타낸다.
              이 값은 <a>크리덴셜</a>의 현재 상태를 판별하기에 충분한 정보를 제공해야 한다.
              예를 들어, <a>크리덴셜</a>의 일시 중지 여부에 대한 외부 문서 링크가 포함될 수 있다.
            </li>
          </ul>
        </dd>
      </dl>
      <p>
        <a>크리덴셜</a> 상태 정보의 정확한 내용은
        특정 <code>credentialStatus</code><a href="#types">유형</a> 정의에 의해 결정되며
        구현이 간단한지 또는 개인정보 보안강화 여부와 같은 요소에 따라 다르다.
      </p>

      <pre class="example nohighlight" title="상태 속성 사용예시">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  "issuer": "https://example.edu/issuers/14",
  "issuanceDate": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"credentialStatus": {
    "id": "https://example.edu/status/24",
    "type": "CredentialStatusList2017"
  }</span>,
  "proof": { <span class="comment">...</span> }
}
        </pre>

      <p>
        상태 체계에 대한 데이터 모델, 형식 및 프로토콜 정의는 이 사양에서 다루지 않는다.
        a>검증가능한 크리덴셜</a> 상태 확인의 구현을 원하는 개발자가 사용할 수 있는
        상태 스키마를 포함하는 Verifiable Credentials Extension Registry [[?VC-EXTENSION-REGISTRY]]가 존재한다.
      </p>
    </section>

    <section id="presentations">
      <h3>프레젠테이션</h3>

      <p>
        <a>프레젠테이션</a>들은 <a>크리덴셜</a>들을 결합하고 제시하는데 사용될 수 있다.
        이들은 데이터의 소유권을 <a>검증가능한</a> 방식으로 결합될 수 있다.
        <a>프레젠테이션</a>의 데이터는 대부분 동일한 <a>주체</a>에 관한 것이지만, 데이터의 <a>주체</a>나 <a>발급자</a> 수에는 제한이 없다.
        여러 <a>검증가능한 크리덴셜</a>에서 정보를 합치는것은 일반적인 <a>검증가능한 프레젠테이션</a>의 사용법이다.
      </p>

      <p>
        <a>검증가능한 프레젠테이션</a>은 보통 다음과 같은 속성들로 구성되어있다.
      </p>

      <dl>
        <dt><var>id</var></dt>
        <dd>
          <code>id</code><a>속성</a>은 선택적이고 <a>프레젠테이션</a>의 고유한 식별자로 사용될 수 있다.
          이 속성에 관한 자세한 사항은 <a href="#identifiers"></a>에서 볼 수 있다.
        </dd>
        <dt><var>type</var></dt>
        <dd>
          <code>type</code><a>속성</a>은 필수적이고 <code>VerifiablePresentation</code> 같이 <a>프레젠테이션</a>의 유형을 표현한다.
          이 속성에 관한 자세한 사항은 <a href="#types"></a>에서 볼 수 있다.
        </dd>
        <dt><var>verifiableCredential</var></dt>
        <dd>
          만약 <code>verifiableCredential</code><a>속성</a>이 존재한다면,
          최소 한개 이상의 <a>검증가능한 프레젠테이션</a>이나
          암호학적으로 <a>검증가능한</a> 형태의 <a>검증가능한 크리덴셜</a>의 데이터로 무조건 구성되어야 한다.
        </dd>
        <dt><var>holder</var></dt>
        <dd>
          만약 <code>holder</code><a>속성</a>이 존재한다면, 이 <a>프레젠테이션</a>을 생성하는 엔터티의 <a>URI</a>여야 한다.
        </dd>
        <dt><var>proof</var></dt>
        <dd>
          만약 <code>proof</code><a>속성</a>이 존재한다면, <code>proof</code>의 값이 <a>프레젠테이션</a>이 <a>검증가능한</a>것임을 보장한다.
          이 속성에 관한 자세한 사항은 <a href="#proofs-signatures"></a>에서 볼 수 있다.
        </dd>
      </dl>

      <p>
        아래 예제는 <a>검증가능한 크리덴셜</a>들을 포함하고 있는 <a>검증가능한 프레젠테이션</a>을 보여준다.
      </p>

      <pre class="example nohighlight" title="프레젠테이션의 기본 구조">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "urn:uuid:3978344f-8596-4c3a-a978-8fcaba3903c5",
  "type": ["VerifiablePresentation", "CredentialManagerPresentation"],
  <span class="highlight">"verifiableCredential": [{ <span class="comment">...</span> }],
  "proof": [{ <span class="comment">...</span> }]</span>
}
        </pre>

      <p>
        위에 표시된 <code>verifiableCredential</code><a>속성</a>의 내용은 이 사양에 설명 된대로 <a>검증가능한 크리덴셜</a>이다.
        <code>proof</code><a>속성</a>의 내용은 Linked Data Proofs [[?LD-PROOFS]] 사양에 설명 된 증명방법이다.
        JWT 증명 방법을 이용한 <a>검증가능한 프레젠테이션</a> 예시는 <a href="#json-web-token"></a>에서 볼 수있다.
      </p>

      <h4>파생된 크리덴셜들로 만드는 프레젠테이션</h4>

      <p>
        일부 영지식 증명 체계는 <a>보유자</a>가 <a>검증가능한 크리덴셜</a> 자체를 밝히지 않고
        <a>검증가능한 크리덴셜</a>으로부터 <a>클레임</a>들을 보유하고 있음을 간접적으로 입증 할 수있도록 해준다.
        이러한 방식에서, <a>검증가능한 크리덴셜</a>의 <a>클레임</a>들은
        제시된 값을 도출한는데 사용될 수 있으며,
        이는 <a>검증자</a>가 <a>발급자</a>를 신뢰하는 경우, 암호학적으로 그 값을 보장할 수 있다.
      </p>

      <p>
        예를 들어, <code>생년월일</code> <a>클레임</a>이 포함된 <a>검증가능한 크리덴셜</a>을 사용하여
        <code>15세 이상</code>의 제시된 값을 암호학적으로 <a>검증가능한</a>방식으로 도출할 수 있다.
        즉, <a>검증자</a>는 <a>발급자</a>를 신뢰하는 경우 파생된 값을 계속 신회할 수 있다.
      </p>

      <p class="note">
        <a>검증가능한 크리덴셜</a>에서 데이터를 직접 내포하지 않고 추출해서 사용하는
        ZKP 스타일의 <a>검증가능한 프레젠테이션</a> 예시를 보고싶다면
        <a href="#zero-knowledge-proofs"></a>를 참조.
      </p>

      <p>
        영지식 증명을 사용하는 선택적 공개 체계에서는 이 모델에 포현된 <a>클레임</a>들을 사용하여
        해당 <a>클레임</a>에 대한 추가적인 주장들을 만들어낼 수 있다.
        예를 들어, 어떤 <a>주체</a>의 생년월일을 나타내는 <a>클레임</a>은
        해당 주체의 나이가 주어진 범위 안에 있음을 증명하는데 사용될 수 있고,
        따라서 대상이 나이 관련 할인을 받을 수 있음을 실제로 <a>주체</a>의 생년월일을 밝히지 않고 증명할 수 있다.
        <a>보유자</a>는 원하는 <a>검증가능한 프레젠테이션</a>에 적용할 수 있는 방식으로 <a>클레임</a>을 사용할 수 있는 유연성을 가지게 된다.
      </p>

      <figure>
        <img style="margin: auto; display: block; width: 50%;" src="diagrams/claim-example-2.svg" alt="Pat has a property
            dateOfBirth whose value is 2010-01-01T19:73:24Z">
        <figcaption style="text-align: center;">
          Pat의 생년월일이 2010-01-01T19:23:24Z라는걸 나타내는 기본적인 클레임. 시간 인코딩은 스키마에따라 결정된다.
        </figcaption>
      </figure>

    </section>
  </section>

  <section id="advanced-concepts">
    <h2>고급 개념</h2>

    <p>
      <a href="#basic-concepts"></a>에서 소개된 개념들을 바탕으로 이 섹션에서는 <a>검증가능한 크리덴셜</a>의 더 복잡한 주제들을 다룬다.
    </p>

    <section class="informative" id="lifecycle-details">
      <h3>라이프사이클 상세</h3>

      <p>
        <a href="#ecosystem-overview"></a>는 <a>검증가능한 크리덴셜</a> 생태계의 개요를 제공했다.
        이 섹션에서는 생태계가 어떻게 작동할 것인지에 대한 자세한 정보를 제공한다.
      </p>

      <figure id="life-cycle-details">
        <img style="margin: auto; display: block; width: 85%;" src="diagrams/ecosystemdetail.svg" alt="diagram showing how
         credentials flow from issuer to holder, and optionally
         from one holder to another; and how
         presentations flow from holder to verifier, where
         all parties can use information from a logical
         verifiable data registry">
        <figcaption style="text-align: center;">
          이 사양의 역할과 정보의 흐름.
        </figcaption>
      </figure>

      <p>
        <a>검증가능한 크리덴셜</a> 생태계의 역할과 정보의 흐름은 다음과 같다:
      </p>

      <ul>
        <li>
          <a>발급자</a>는 <a>검증가능한 크리덴셜</a>을 <a>보유자</a>에게<dfn data-lt="issue">발급</dfn>한다.
          발급은 항상 <a>크리덴셜</a>과 관련된 다른 작업보다 먼저 발생한다.
        </li>
        <li>
          <a>보유자</a>는 하나 이상의 <a>검증가능한 크리덴셜</a>을 다른 <a>보유자</a>에게 <dfn data-lt="transfers">양도</dfn>할 수 있다.
        </li>
        <li>
          <a>보유자</a>는 하나 이상의 <a>검증가능한 크리덴셜</a>을, 선택적으로 <a>검증가능한 프레젠테이션</a>에 포함하여, <a>검증자</a>에게 <dfn
            data-lt="present">제시</dfn>한다.
        </li>
        <li>
          <a>검증자</a>는 제시된 <a>검증가능한 프레젠테이션</a>과 <a>검증가능한 크리덴셜</a>의 진위를 <a>검증</a>한다. 여기에는 <a>검증가능한 크리덴셜</a>의 폐기 여부가 확인되어야
          한다.
        </li>
        <li>
          <a>발급자</a>는 <a>검증가능한 크리덴셜</a>를 취소할 수 있다.
        </li>
        <li>
          <a>보유자</a>는 <a>검증가능한 크리덴셜</a>을 <dfn data-lt="delete">삭제</dfn>할 수 있다.
        </li>
      </ul>

      <p class="note">
        위 내용들의 순서는 고정되어 있지 않으며 일부 동작들은 두 번 이상 수행될 수 있다. 이러한 재동작은 즉시 또는 나중에 발생할 수 있다.
      </p>

      <p>
        가장 일반적인 동작 순서는 다음과 같다:
      </p>

      <ol>
        <li>
          <a>발급자</a>가 <a>보유자</a>에게 <a href="#lifecycle-details">발급한다</a>.
        </li>
        <li>
          <a>보유자</a>가 <a>검증자</a>에게 <a href="#lifecycle-details">제시한다</a>.
        </li>
        <li>
          <a>검증자</a>가 <a href="#lifecycle-details">검증한다</a>.
        </li>
      </ol>

      <p>
        이 사양은 <a>검증가능한 크리덴셜</a> 또는 <a>검증가능한 프레젠테이션</a>을 전송하기 위한 프로토콜을 정의하지 않지만, 다른 사양에서 엔터티간 전송 방법을 지정한다고 가정하면 이 검증가능한
        크리덴셜 데이터 모델을 바로 적용할 수 있다.
      </p>

      <p>
        이 사양은 인증 프레임워크나 <a>검증자</a>가 <a>보유자</a>, <a>검증가능한 크리덴셜</a>의 <a>발급자</a>, <a>검증가능한 크리덴셜</a>의 내용, 그리고 자체 정책을 고려하여
        <a>검증가능한 크리덴셜</a> 또는 <a>검증가능한 프레젠테이션</a>을 검증한 후 내리는 결정에 대해 정의하지 않는다.
      </p>

      <p>
        특히 <a href="#terms-of-use"></a>와 <a href="#subject-holder-relationships"></a>는 <a>검증자</a>가 다음 사항들을 결정할 수 있는 방법을
        지정한다:
      </p>

      <ul>
        <li>
          <a>보유자</a>가 해당 <a>검증가능한 크리덴셜</a>의 <a>주체</a>인지 여부.
        </li>
        <li>
          <a>주체</a>와 <a>보유자</a>의 관계.
        </li>
        <li>
          이전 <a>보유자</a>가 <a>검증가능한 크리덴셜</a>을 후속 <a>보유자</a>에게 전달했는지 여부.
        </li>
        <li>
          <a>보유자</a> 또는 <a>검증자</a>가 <a>검증가능한 크리덴셜</a>을 사용하는데 모든 제한 사항들.
        </li>
      </ul>
    </section>

    <section class="informative" id="trust-model">
      <h2>신뢰 모델</h2>

      <p>
        <a>검증가능한 크리덴셜</a>의 신뢰 모델은 다음과 같다:
      </p>

      <ul>
        <li>
          <a>검증자</a>는 자신이 받은 <a>크리덴셜</a>이 <a>발급자</a>가 발급한 것이 맞다는 것을 신뢰한다.
          이러한 신뢰를 형성하기 위해서 <a>크리덴셜</a>은 다음 중 하나를 만족해야 한다:
          <ul>
            <li>
              <a>발급자</a>가 생성한 <a>크리덴셜</a>임을 규명하는 <a href="#proofs-signatures">프루프</a>를 포함하거나,
              (즉, <a>검증가능한 크리덴셜</a>이거나)
            </li>
            <li>
              <a>발급자</a>가 그 <a>검증가능한 크리덴셜</a>을 생성했다는 것과 그 <a>검증가능한 크리덴셜</a>의 전송 및 저장 과정에서
              훼손되지 않았음을 명확히 규명할 수 있는 방법을 통해 전달되어야 한다.
              이러한 신뢰는 <a>검증자</a>의 위험 평가 결과에 따라 취약할 수도 있다.
            </li>
          </ul>
        </li>
        <li>
          모든 <a>개체들</a>은 <a>검증가능한 데이터 레지스트리</a>가 훼손 방지 기능이 있고,
          어떤 데이터가 어떤 <a>개체</a>에 의해 컨트롤되는지에 대한 올바른 기록을 가지고 있음을 신뢰한다.
        </li>
        <li>
          <a>보유자</a>와 <a>검증자</a>는 <a>발급자</a>가 <a>주체</a>에 대해
          사실 관계가 올바른 (즉, 거짓이 아닌) <a>크리덴셜</a>을 발급했다는 것과
          도용시 빠르게 그 <a>크리덴셜</a>을 폐기한다는 것을 신뢰한다.
        </li>
        <li>
          <a>보유자</a>는 <a>저장소</a>가 <a>크리덴셜</a>을 안전하게 저장한다는 것과
          <a>보유자</a>가 아닌 다른 누구에게도 그 <a>크리덴셜</a>을 내보내지 않는다는 것,
          그리고 <a>저장소</a>가 관리하고 있는 한 오류나 손실이 없다는 것을 신뢰한다.
        </li>
      </ul>

      <p>
        이 신뢰 모델은 다음 사항을 보장함으로써 다른 신뢰 모델과 차별점을 갖는다:
      </p>

      <ul>
        <li>
          <a>발급자</a>와 <a>검증자</a>는 <a>저장소</a>를 신뢰할 필요가 없다.
        </li>
        <li>
          <a>발급자</a>는 <a>검증자</a>를 알아야 할 필요도 없고, 믿어야 할 필요도 없다.
        </li>
      </ul>

      <p>
        <a>신원 제공자</a>와 <a>신뢰 당사자</a>간의 신뢰 결합을 제거함으로써 더 유연하고 동적인 신뢰 모델이 생성되고,
        그로 인해 시장 경쟁이 치열해지고 고객 선택의 폭이 증가한다.
      </p>

      <p>
        워킹 그룹에서 연구한 이 신뢰 모델이 어떻게 다양한 위협 모델과 상호작용하는가에 대한
        더 많은 정보는 검증가능한 크리덴셜 유즈케이스 문서 참조. [[VC-USECASES]]
      </p>

      <p class="note">
        이 규격에서 설명하고 있는 데이터 모델은 전통적인 인증 기관의 신뢰 모델에서 제공하는 것과 같은
        전이 가능한(transitive) 신뢰 모델을 내포하지는 않는다.
        검증가능한 크리덴셜 데이터 모델에서 <a>검증자</a>는 <a>발급자</a>를 직접 믿을 수도 있고 믿지 않을 수도 있다.
        검증가능한 크리덴셜 데이터 모델을 이용하는 전이 가능한 신뢰 모델을 구축하는 것이 가능함에도 불구하고,
        구현자는 인증 기관 시스템에서 채택했던 것과 마찬가지로
        <a href="https://www.cs.cornell.edu/people/egs/papers/dnssurvey.pdf">광범위 위임 신뢰(broadly delegating trust)</a>에서
        소개된
        <a href="https://tools.ietf.org/html/draft-housley-web-pki-problems">보안 취약점에 대해 공부</a>해야 한다.
      </p>
    </section>

    <section id="extensibility">
      <h3>확장성</h3>

      <p>
        검증가능한 크리덴셜 데이터 모델의 목표 중 하나는 비허가형 방식의 혁신을 활성화하는데 있다.
        이러한 목표를 달성하기 위하여, 이 데이터 모델은 수많은 다른 방법으로 확장가능할 필요가 있다.
        이 데이터 모델에 요구되는 것은:
      </p>

      <ul>
        <li>
          <a>그래프</a>기반 데이터 모델을 사용하여 복잡한 다중-개체 관계 모형을 만든다.
        </li>
        <li>
          [[?LINKED-DATA]]의 사용을 통하여, 중앙화된 시스템 없이도,
          데이터 모델 안에 있는 정보를 기술하는데 사용되는 기계 판독 가능 어휘 목록을 확장한다.
        </li>
        <li>
          연결 데이터 프루프(Linked Data Proofs, [[?LD-PROOFS]]) 및 연결 데이터 서명(Linked Data Signatures, [[?LD-SIGNATURES]])
          그리고 다양한 서명 제품군(signature suites)의 사용을 통해 여러 유형의 암호학적 프루프 형식을 지원한다.
        </li>
        <li>
          소프트웨어 개발자 및 웹 페이지 제작자들에게 자주 쓰이고,
          [[JSON-LD]]의 사용을 통해 활성화 된 데이터 형식에서 상술한 모든 확장 메커니즘을 제공한다.
        </li>
      </ul>

      <p>
        데이터 모델링에 대한 이러한 접근 방식은 종종 <em>“열린 세계 가정 (open world assumption)"</em>이라고하며,
        이는 누구나 다른 누군가에 대해 말할 수 있다는 것을 의미한다.
        이러한 접근 방식이 간단하고 예측 가능한 소프트웨어 시스템을 구축하는 것과 충돌하는 것처럼 보일 수 있음에도 불구하고,
        프로그램의 정확성과 확장성 간에 균형을 맞추는 것은 폐쇄형 소프트웨어 시스템보다 열린 세계 가정에서 항상 더 도전적인 과제이다.
      </p>

      <p>
        이 섹션의 나머지 부분에서는 여러 예제들을 통해 확장성과 프로그램 정확성을 모두 달성하는 방법에 대해 설명한다.
      </p>

      <p>
        다음과 같은 <a>검증가능한 크리덴셜</a>로 시작한다고 간주해보자.
      </p>

      <pre class="example nohighlight" title="간단한 크리덴셜">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.com/credentials/4643",
  "type": ["VerifiableCredential"],
  "issuer": "https://example.com/issuers/14",
  "issuanceDate": "2018-02-24T05:28:04Z",
  "credentialSubject": {
    "id": "did:example:abcdef1234567",
    "name": "Jane Doe"
  },
  "proof": { <span class="comment">...</span> }
}
        </pre>

      <p>
        이 <a>검증가능한 크리덴셜</a>이 나타내는 것은
        이 <a>개체</a>가 <code>name</code> 속성의 값이 <code>Jane Doe</code>라는 값을 가진
        <code>did:example:abcdef1234567</code>과 관련있다는 것이다.
      </p>

      <p>
        이제 어떤 개발자가 이 <a>검증가능한 크리덴셜</a>을 확장해서
        두 개의 추가적인 정보를 저장하고 싶다고 해보자:
        내부 기업 참조 번호와 Jane이 가장 좋아하는 음식.
      </p>

      <p>
        첫 번째로 해야할 일은 아래와 같이 두 개의 새로운 용어가 포함된 JSON-LD 컨텍스트를 생성하는 것이다.
      </p>

      <pre class="example nohighlight" title="JSON-LD 컨텍스트">
{
  "@context": {
    "referenceNumber": "https://example.com/vocab#referenceNumber",
    "favoriteFood": "https://example.com/vocab#favoriteFood"
  }
}
        </pre>

      <p>
        이 JSON-LD 컨텍스트가 생성된 이후에,
        그 개발자는 생성한 것을 어딘가에 발행해서 이 <a>검증가능한 크리덴셜</a>을 처리할 <a>검증자</a>가 접근할 수 있도록 만든다.
        위의 JSON-LD 컨텍스트가 <code>https://example.com/contexts/mycontext.jsonld</code>에 발행되었다고 가정하면,
        우리는 이 <a>검증가능한 크리덴셜</a>에 컨텍스트를 포함하고
        새로운 <a>속성</a> 및 <a>크리덴셜</a> <a>타입</a>을 추가함으로써 이 예제를 확장할 수 있게 된다.
      </p>

      <pre class="example nohighlight" title="사용자 지정 확장된 검증가능한 크리덴셜">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    <span class="highlight">"https://example.com/contexts/mycontext.jsonld"</span>
  ],
  "id": "http://example.com/credentials/4643",
  "type": ["VerifiableCredential", "CustomExt12"],
  "issuer": "https://example.com/issuers/14",
  "issuanceDate": "2018-02-24T05:28:04Z",
  <span class="highlight">"referenceNumber": 83294847,</span>
  "credentialSubject": {
    "id": "did:example:abcdef1234567",
    "name": "Jane Doe",
    <span class="highlight">"favoriteFood": "Papaya"</span>
  },
  "proof": { <span class="comment">...</span> }
}
        </pre>

      <p>
        이 예제는 검증가능한 크리덴셜 데이터 모델이 비허가형이고 탈중화된 방식으로 확장되는 것을 보여준다.
        이 메커니즘은 또한, 이런 방식으로 생성된 <a>검증가능한 크리덴셜</a>이 네임스페이스 충돌 및 의미 중의성을 방지하기 위한
        메커니즘을 제공한다는 것을 확실히 보여준다.
      </p>

      <p>
        이러한 동적 확장성 모델은 구현 부담을 분명히 증가시킨다.
        이런 시스템용으로 작성된 소프트웨어는,
        응용 프로그램의 위험 프로파일을 기반으로 확장된 <a>검증가능 크리덴셜</a>을 받아들일지 여부를 결정해야한다.
        어떤 응용 프로그램은 특정 확장을 허용하면서도 높은 보안성이 요구되는 환경에서는
        모든 확장을 허용하지 않을 수 있다.
        이러한 결정은 응용 프로그램 개발자에게 달려 있으며 이 규격에서 구체적으로 다루는 영역이 아니다.
      </p>

      <p>
        개발자는 확장된 JSON-LD 컨텍스트의 가용성을 높이기 위해 노력해야 한다.
        컨텍스트를 가져올 수 없는 구현물은 오류를 발생 시킬 것이다.
        컨텍스트를 위한 내용 지정 URL들의 사용, 컨텍스트 문서와 구현물의 번들링,
        또는 컨텍스트의 적극적인 캐싱 활성화를 포함하여 확장 JSON-LD 컨텍스트를 보장하는 전략은 언제나 유효하다.
      </p>

      <p>
        Implementers are advised to pay close attention to the extension points in this
        specification, such as in Sections <a href="#proofs-signatures"></a>,
        <a href="#status"></a>, <a href="#data-schemas"></a>,<a href="#refreshing"></a>,
        <a href="#terms-of-use"></a>, and <a href="#evidence"></a>. While this
        specification does not define concrete implementations for those extension

        구현자는 <a href="#proofs-signatures"></a>,
        <a href="#status"></a>, <a href="#data-schemas"></a>, <a href="#refreshing"></a>,
        <a href="#terms-of-use"></a>, <a href="#evidence"></a>
        에서
        설명하고 있는 확장 기능에 대단히 주의를 기울여야 한다.
        비록 이 규격이 확장 기능과 관련한 구체적인 구현에 대해 정의하고 있진 않지만,
        검증가능한 크리덴셜 확장 레지스트리[VC-EXTENSION-REGISTRY]는
        개발자가 활용할 수 있도록 비공식적인 확장 기능 목록을 제공한다.
      </p>

      <section id="semantic-interoperability">
        <h4>Semantic Interoperability</h4>

        <p>
          This specification ensures that "plain" JSON and JSON-LD syntaxes are
          semantically compatible without requiring JSON implementations to use a JSON-LD
          processor. To achieve this, the specification imposes the following additional
          requirements on both syntaxes:
        </p>

        <ul>
          <li>
            JSON-based processors MUST process the <code>@context</code> key, ensuring the
            expected values exist in the expected order for the <a>credential</a> type being
            processed. The order is important because keys used in a <a>credential</a>,
            which are defined using the values associated with <code>@context</code>, are
            defined using a "first defined wins" mechanism and changing the order might
            result in a different key definition "winning".
          </li>
          <li>
            JSON-LD-based processors MUST produce an error when a JSON-LD context redefines
            any term in the
            <a href="https://www.w3.org/TR/json-ld/#dfn-active-context">active context</a>.
            The only way to change the definition of existing terms is to introduce a new
            term that clears the active context within the scope of that new term. Authors
            that are interested in this feature should read about the
            <code>@protected</code> feature in the JSON-LD 1.1 specification.
          </li>
        </ul>

        <p>
          A human-readable document describing the expected order of values for the
          <code>@context</code> <a>property</a> is expected to be published by any
          implementer seeking interoperability. A machine-readable description
          (that is, a normal JSON-LD Context document) is expected to be published
          at the URL specified in the <code>@context</code> <a>property</a> by
          JSON-LD implementers seeking interoperability.
        </p>

        <p>
          The requirements above guarantee semantic interoperability between JSON and
          JSON-LD for terms defined by the <code>@context</code> mechanism. While JSON-LD
          processors will use the specific mechanism provided and can verify that all
          terms are correctly specified, JSON-based processors implicitly accept the same
          set of terms without testing that they are correct. In other words, the context
          in which the data exchange happens is explicitly stated for both JSON and
          JSON-LD by using the same mechanism. With respect to JSON-based processors, this
          is achieved in a lightweight manner, without having to use JSON-LD processing
          libraries.
      </section>
    </section>

    <section>
      <h3>Data Schemas</h3>

      <p>
        Data schemas are useful when enforcing a specific structure on a given
        collection of data. There are at least two types of data schemas that this
        specification considers:
      </p>

      <ul>
        <li>
          Data verification schemas, which are used to <a>verify</a> that the structure
          and contents of a <a>verifiable credential</a> conform to a published schema.
        </li>
        <li>
          Data encoding schemas, which are used to map the contents of a
          <a>verifiable credential</a> to an alternative representation format, such as a
          binary format used in a zero-knowledge proof.
        </li>
      </ul>

      <p>
        It is important to understand that data schemas serve a different purpose from
        the <code>@context</code> property, which neither enforces data structure or
        data syntax, nor enables the definition of arbitrary encodings to alternate
        representation formats.
      </p>

      <p>
        This specification defines the following <a>property</a> for the expression of a
        data schema:
      </p>

      <dl>
        <dt><var>credentialSchema</var></dt>
        <dd>
          The value of the <code>credentialSchema</code> <a>property</a> MUST be one or
          more data schemas that provide <a>verifiers</a> with enough information to
          determine if the provided data conforms to the provided schema. Each
          <code>credentialSchema</code> MUST specify its <code>type</code> (for example,
          <code>JsonSchemaValidator2018</code>), and an <code>id</code> <a>property</a>
          that MUST be a <a>URI</a> identifying the schema file. The precise contents of
          each data schema is determined by the specific type definition.
        </dd>
      </dl>

      <p class="note">
        The <code>credentialSchema</code> <a>property</a> provides an opportunity to
        annotate type definitions or lock them to specific versions of the vocabulary.
        Authors of <a>verifiable credentials</a> can include a static version of their
        vocabulary using <code>credentialSchema</code> that is locked to some content
        integrity protection mechanism. The <code>credentialSchema</code>
        <a>property</a> also makes it possible to perform syntactic checking on the
        <a>credential</a> and to use <a>verification</a> mechanisms such as JSON Schema
        [[JSON-SCHEMA-2018]] validation.
      </p>

      <pre class="example nohighlight" title="Usage of the credentialSchema property to perform JSON schema validation">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  "issuer": "https://example.edu/issuers/14",
  "issuanceDate": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"credentialSchema": {
    "id": "https://example.org/examples/degree.json",
    "type": "JsonSchemaValidator2018"
  }</span>,
  "proof": { <span class="comment">...</span> }
}
        </pre>

      <p>
        In the example above, the <a>issuer</a> is specifying a
        <code>credentialSchema</code>, which points to a [[?JSON-SCHEMA-2018]] file that
        can be used by a <a>verifier</a> to determine if the
        <a>verifiable credential</a> is well formed.
      </p>

      <p class="note">
        For information about linkages to JSON Schema [[JSON-SCHEMA-2018]] or other
        optional <a>verification</a> mechanisms, see the Verifiable Credentials
        Implementation Guidelines [[VC-IMP-GUIDE]] document.
      </p>

      <p>
        Data schemas can also be used to specify mappings to other binary formats, such
        as those used to perform zero-knowledge proofs. For more information on using
        the <code>credentialSchema</code> <a>property</a> with zero-knowledge proofs,
        see Section <a href="#zero-knowledge-proofs"></a>.
      </p>

      <pre class="example nohighlight"
        title="Usage of the credentialSchema property to perform zero-knowledge validation">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  "issuer": "https://example.edu/issuers/14",
  "issuanceDate": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"credentialSchema": {
    "id": "https://example.org/examples/degree.zkp",
    "type": "ZkpExampleSchema2018"
  }</span>,
  "proof": { <span class="comment">...</span> }
}
        </pre>

      <p>
        In the example above, the <a>issuer</a> is specifying a
        <code>credentialSchema</code> pointing to a zero-knowledge packed binary data
        format that is capable of transforming the input data into a format, which can
        then be used by a <a>verifier</a> to determine if the proof provided with the
        <a>verifiable credential</a> is valid.
      </p>

    </section>

    <section>
      <h3>Refreshing</h3>

      <p>
        It is useful for systems to enable the manual or automatic refresh of an
        expired <a>verifiable credential</a>. For more information about expired
        <a>verifiable credentials</a>, see Section <a href="#expiration"></a>. This
        specification defines a <code>refreshService</code> <a>property</a>, which
        enables an <a>issuer</a> to include a link to a refresh service.
      </p>
      <p>
        The <a>issuer</a> can include the refresh service as an element inside the
        <a>verifiable credential</a> if it is intended for either the <a>verifier</a> or
        the <a>holder</a> (or both), or inside the <a>verifiable presentation</a> if it
        is intended for the <a>holder</a> only. In the latter case, this enables the
        <a>holder</a> to refresh the <a>verifiable credential</a> before creating a
        <a>verifiable presentation</a> to share with a <a>verifier</a>. In the former
        case, including the refresh service inside the <a>verifiable credential</a>
        enables either the <a>holder</a> or the <a>verifier</a> to perform future
        updates of the <a>credential</a>.
      </p>
      <p>
        The refresh service is only expected to be used when either the
        <a>credential</a> has expired or the <a>issuer</a> does not publish
        <a>credential</a> status information. <a>Issuers</a> are advised not to put the
        <code>refreshService</code> <a>property</a> in a <a>verifiable credential</a>
        that does not contain public information or whose refresh service is not
        protected in some way.
      </p>
      <p class="note">
        Placing a <code>refreshService</code> <a>property</a> in a
        <a>verifiable credential</a> so that it is available to <a>verifiers</a> can
        remove control and consent from the <a>holder</a> and allow the
        <a>verifiable credential</a> to be issued directly to the <a>verifier</a>,
        thereby bypassing the <a>holder</a>.
      </p>

      <dl>
        <dt><var>refreshService</var></dt>
        <dd>
          The value of the <code>refreshService</code> <a>property</a> MUST be one or
          more refresh services that provides enough information to the recipient's
          software such that the recipient can refresh the <a>verifiable credential</a>.
          Each <code>refreshService</code> value MUST specify its <code>type</code> (for
          example, <code>ManualRefreshService2018</code>) and its <code>id</code>, which
          is the URL of the service. The precise content of each refresh service is
          determined by the specific <code>refreshService</code> <a>type</a> definition.
        </dd>
      </dl>

      <pre class="example nohighlight" title="Usage of the refreshService property by an issuer">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  "issuer": "https://example.edu/issuers/14",
  "issuanceDate": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"refreshService": {
    "id": "https://example.edu/refresh/3732"
    "type": "ManualRefreshService2018",
  }</span>,
  "proof": { <span class="comment">...</span> }
}
        </pre>

      <p>
        In the example above, the <a>issuer</a> specifies a manual
        <code>refreshService</code> that can be used by directing the <a>holder</a> or
        the <a>verifier</a> to <code>https://example.edu/refresh/3732</code>.
      </p>

    </section>

    <section id="terms-of-use">
      <h3>이용약관</h3>

      <p>
        이용약관은 <a>발급자</a> 또는 <a>보유자</a>가 <a>검증가능한 크리덴셜</a> 또는
        <a>검증가능한 프레젠테이션</a>이 발급 된 조건을 전달하기 위해 사용될 수 있다.
        <a>발급자</a>는 이용약관을 <a>검증가능한 크리덴셜</a>에 배치한다.
        <a>보유자</a>는 이용약관을 <a>검증가능한 프레젠테이션</a>에 배치한다.
        본 명세서에서는 이용약관 정보를 표현하기 위한 <code>termsOfUse</code> <a>속성</a>을 정의한다.
      </p>

      <p>
        <code>termsOfUse</code> <a>속성</a>의 값은 <a>검증자</a>에게
        <a>검증가능한 크리덴셜</a> 또는 <a>검증가능한 프레젠테이션</a>을
        승인할 경우 수행해야 하는 조치 (<em>의무</em>), 수행이 허용되지 않거나
        (<em>금지</em>) 또는 수행이 허용되는 (<em>허가</em>) 조치를
        <a>검증자</a>에게 전한다.
      </p>

      <p class="note">
        <a>보유자</a>가 아닌 <a>주체</a>가 <a>검증가능한 크리덴셜</a>에
        이용약관을 배치하는 방법을 결정하기 위해서 추가 연구가 필요하다.
        한가지 방법은 <a>주체</a>가 <a>발급자</a>에게 발급된
        <a>검증가능한 크리덴셜</a> 내에 이용 약관을 배치하도록 요청할 수 있다.
        다른 방법은 <a>주체</a>가 <a>검증가능한 크리덴셜</a>을 <a>보유자</a>에게
        위임하고 위임된 <a>검증가능한 크리덴셜</a>에 이용 약관 제한을 설정할 수 있다.
      </p>

      <dl>
        <dt><var>termsOfUse</var></dt>
        <dd>
          <code>termsOfUse</code> <a>속성</a>의 값은 무조건 작성자가 <a>크리덴셜</a> 또는
          <a>프레젠테이션</a>을 발행 한 하나 이상의 이용 약관 정책을 지정해야만 한다.
          수령자 (<a>보유자</a> 또는 <a>검증자</a>)가 지정된 이용 약관을 준수하지 않을 경우,
          책임을 지고 명시된 이용 약관을 위반할 경우 법적 책임을 질 수 있다.
          각 <code>termsOfUse</code> 값은 <a>타입</a>을 지정해야 하고
          (예: <code>IssuerPolicy</code>), 인스턴스 <code>id</code>를 지정할 수 있다.
          각 이용 약관의 정확한 내용은 특정 code>termsOfUse</code> <a>타입</a> 정의에 의해
          결정된다.
        </dd>
      </dl>

      <pre class="example nohighlight" title="발급자에 의한 termsOfUse 속성 사용">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  "issuer": "https://example.edu/issuers/14",
  "issuanceDate": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"termsOfUse": [{
    "type": "IssuerPolicy",
    "id": "http://example.com/policies/credential/4",
    "profile": "http://example.com/profiles/credential",
    "prohibition": [{
      "assigner": "https://example.edu/issuers/14",
      "assignee": "AllVerifiers",
      "target": "http://example.edu/credentials/3732",
      "action": ["Archival"]
    }]
  }</span>,
  "proof": { <span class="comment">...</span> }
}
        </pre>

      <p>
        위의 예에서 <a>발급자</a>(<code>assigner</code>, 양도자)는
        <a>검증자</a>(<code>assignee</code>, 양수자)가 데이터를 아카이브에 저장하지 못하도록 금지한다.
      </p>

      <pre class="example nohighlight" title="보유자에 의한 termsOfUse 속성 사용">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
  "type": ["VerifiablePresentation"],
  "verifiableCredential": [{
    "@context": [
      "https://www.w3.org/2018/credentials/v1",
      "https://www.w3.org/2018/credentials/examples/v1"
    ],
    "id": "http://example.edu/credentials/3732",
    "type": ["VerifiableCredential", "UniversityDegreeCredential"],
    "issuer": "https://example.edu/issuers/14",
    "issuanceDate": "2010-01-01T19:23:24Z",
    "credentialSubject": {
      "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
      "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
    },
    "proof": { <span class="comment">...</span> }
  }],
  <span class="highlight">"termsOfUse": [{
    "type": "HolderPolicy",
    "id": "http://example.com/policies/credential/6",
    "profile": "http://example.com/profiles/credential",
    "prohibition": [{
      "assigner": "did:example:ebfeb1f712ebc6f1c276e12ec21",
      "assignee": "https://wineonline.example.org/",
      "target": "http://example.edu/credentials/3732",
      "action": ["3rdPartyCorrelation"]
    }]
  }</span>,
  "proof": [ ... ]
}
        </pre>

      <p>
        위의 예에서, <a>주체</a>인 <a>보유자</a>(<code>assigner</code>, 양도자)는
        <a>검증자</a>(<code>assignee</code>, 양수자, <code>https://wineonline.example.org</code>)가
        제 3자 서비스를 사용하여 <a>보유자</a> 또는 <a>주체</a>의 상관관계를 표현하기 위해
        제공된 정보를 사용하는 것을 금지하는 사용 기간을 명시한다.
        <a>검증자</a>가 상관관계를 위해 제 3자 서비스를 사용하는 경우,
        <a>보유자</a>는 <a>프레젠테이션</a>을 작성하는 조건을 위반한다.
      </p>

      <p>
        이 기능은 정부에서 발행한 <a>검증가능한 크리덴셜</a>에 의해 사용되어 전자 지갑이
        시민들의 민감한 데이터를 예기치 않게 사용되는 것을 막기 위하여 유사한 정부 기관으로의
        사용을 제한하도록 지시한다. 유사하게 민간 산업에서 발행한
        <a>검증가능한 크리덴셜</a>은 조직, 부서 내 또는 업무 시간동안 사용을 제한할
        것으로 예상된다. 구현자는 검증가능한 크리덴셜 구현 지침 [[?VC-IMP-GUIDE]] 문서의
        적합한 장에서 빠르게 발전하는 기능에 대하여 자세히 읽어야 한다.
      </p>

    </section>

    <section id="evidence">
      <h3>증거</h3>

      <p>
        <a>발급자</a>는 <a>검증자</a>에게 <a>검증가능한 크리덴셜</a>에 추가 지원 정보를
        제공하기 위하여 증거가 포함될 수 있다. 이것은 <a>검증자</a>에 의해
        <a>검증가능한 크리덴셜</a>의 요구에 의존하는 신뢰를 설정하기 위해 사용될 수 있다.
      </p>
      <p>
        예를 들어, <a>발급자</a>는 <a>크리덴셜</a>을 발급하기 전에 <a>주체</a>가 제공한
        실제 문서를 확인하거나 사전 검사를 수행할 수 있다. 특정 시나리오에서 이 정보는 주어진
        <a>크리덴셜</a>에 의존하는 것과 관련된 위험을 결정할 때 <a>검증자</a>에게 유용하다.
      </p>

      <p>
        본 명세서는 증거 정보를 표현하기위한 <code>evidence</code> <a>속성</a>을 정의한다.
      </p>

      <dl>
        <dt><var>evidence</var></dt>
        <dd>
          <code>evidence</code> <a>속성</a>의 값은 무조건 <a>검증자</a>가 <a>발급자</a>에
          의해 수집한 증거가 <a>크리덴셜</a>에 의존하기 위한 신뢰 요구 사항을 충족하는지 여부를
          판단할 수 있는 충분한 정보를 제공하는 하나 이상의 증거 체계이어야만 한다.
          각 증거 체계는 <a>타입</a>별로 식별된다.
          <code>id</code> <a>속성</a>은 선택 사항이지만 존재한다면, 이 증거 인스턴스에 대한
          추가 정보를 찾을 수 있는 URL을 포함해야 한다. 각 증거 체계의 정확한 내용은 특정
          <code>evidence</code> <a>타입</a> 정의에 의해 결정된다.
        </dd>
      </dl>

      <p class="note">
        명세서에서 <a>크리덴셜</a> 및 크리덴셜이 아닌 데이터에 대한 첨부 및 참조를 지원하는
        방법에 대한 자세한 내용은 검증가능한 크리덴셜 구현 지침 [[VC-IMP-GUIDE]] 문서를 참조.
      </p>

      <pre class="example nohighlight" title="증거 속성의 사용">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  "issuer": "https://example.edu/issuers/14",
  "issuanceDate": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"evidence": [{
    "id": "https://example.edu/evidence/f2aeec97-fc0d-42bf-8ca7-0548192d4231",
    "type": ["DocumentVerification"],
    "verifier": "https://example.edu/issuers/14",
    "evidenceDocument": "DriversLicense",
    "subjectPresence": "Physical",
    "documentPresence": "Physical"
  },{
    "id": "https://example.edu/evidence/f2aeec97-fc0d-42bf-8ca7-0548192dxyzab",
    "type": ["SupportingActivity"],
    "verifier": "https://example.edu/issuers/14",
    "evidenceDocument": "Fluid Dynamics Focus",
    "subjectPresence": "Digital",
    "documentPresence": "Digital"
  }]</span>,
  "proof": { <span class="comment">...</span> }
}
        </pre>

      <p class="note">
        <code>evidence</code> <a>속성</a>은 <code>proof</code> <a>속성</a>에 대하여
        서로 다른 보완 정보를 제공한다. <code>evidence</code> <a>속성</a>은
        <a>검증가능한 크리덴셜</a>의 무결성과 관련된 문서 증거와 같은 지원 정보를 표현하는 데
        사용된다. 반면에 <code>proof</code> <a>속성</a>은 <a>발급자</a>의 진위 및
        <a>검증가능한 크리덴셜</a>의 무결성과 관련된 기계-검증가능한 수학적 증명을
        표현하는 데 사용된다. <code>proof</code> <a>속성</a>에 대한 자세한 내용은
        <a href="#proofs-signatures"></a>을 참조.
      </p>

    </section>

    <section id="zero-knowledge-proofs">
      <h3>영지식 증명</h3>

      <p>
        영지식 증명은 개체가 실제 값을 공개하지 않고 특정 값을 알고 있음을 다른 개체에 증명할 수 있는 암호학적 방법이다.
        실제 예를 들면 당신의 신분 또는 학위에 포함된 다른 개인 식별 정보 드러내지 않고,
        공인된 대학이 당신에게 학위를 수여했음을 증명하는 것이다.
      </p>
      <p>
        영지식 증명 메커니즘에 의해 도입된 주요 기능은 <a>보유자</a>가 다음을 수행할 수 있게 한다.

      </p>

      <ul>
        <li>
          <a>검증가능한 크리덴셜</a> 또는 주체 식별자를 검증자에게 공개하지 않고
          여러 <a>발급자</a>의 여러 <a>검증가능한 크리덴셜</a>을
          단일의 <a>검증가능한 프레젠테이션</a>으로 결합 할 수 있는 기능.
          이로 인해 <a>검증자</a>는 발급된 <a>검증가능한 크리덴셜</a>과 관련해
          어떤 발급자와도 공모하는 것이 더 어려워진다.

        </li>
        <li>
          다수의 원자적 <a>검증가능한 크리덴셜</a>의 발행에 대한 요구 없이
          <a>검증자</a>에게 <a>검증가능한 크리덴셜</a>의 <a>클레임</a>을 선택적으로 공개하는 기능.
          이를 통해 <a>보유자</a>는 <a>검증자</a>에게 불필요한 정보제공 없이 필요한 정보만 정확하게 제공할 수 있다.
        </li>
        <li>
          검증가능한 크리덴셜을 발급 받고 나면,
          추가적인 <a>발급자</a>의 관여 없이도 <a>발급자</a>가 아닌 <a>검증자</a>의 데이터 스키마 형식에 따라
          파생된 <a>검증가능한 크리덴셜</a>을 생성할 수 있는 기능.
          이를 통해 <a>보유자</a>가 발급 받은 <a>검증가능한 크리덴셜</a>을 사용함에 있어 유연성이 크게 향상된다.
        </li>
      </ul>

      <p>
        이 규격은 영지식 증명 메커니즘을 지원하는 데이터 모델을 설명한다.
        아래 예는 데이터 모델을 사용하여 영지식 <a>검증가능한 크리덴셜</a>을 발급, 제시 및 검증 하는 방법을 보여준다.

      </p>

      <p>
        영지식 <a>검증가능한 크리덴셜</a>을 사용하려면
        <a>발급자</a>는 반드시 <a>보유자</a>가 프라이버시 강화 방식으로 검증자에게 정보 제시가 가능하도록
        <a>검증가능한 크리덴셜</a>을 발급해야 한다.
        이는 <a>보유자</a>가 서명된 값을 밝히지 않거나 선택된 특정 값만 밝힐 때에도
        <a>발급자</a> 서명의 유효성을 입증할 수 있음을 의미한다.
        표준 관행은 서명 자체를 밝히지 않고, 서명에 대한 지식을 증명함으로써 그렇게 하는 것이다.
        <a>검증가능한 크리덴셜</a>을 영지식 증명 시스템에서 사용할 때 두 가지 요구 사항이 있다.
        <a>검증가능한 크리덴셜</a>은 반드시 다음을 포함해야 한다.

      </p>

      <ul>
        <li>
          <code>credentialSchema</code> <a>속성</a>을 사용한 <a>크리덴셜</a>의 정의.
          모든 당사자가 다양한 영지식 암호화 작업을 수행하는 데 사용할 수 있다.

        </li>
        <li>
          <code>proof</code> <a>속성</a>을 사용한 프루프.
          이것은 원본 <a>검증가능한 크리덴셜</a>에 포함 된 정보를 영지식으로 제시하는
          <a>검증가능한 프레젠테이션</a>을 도출하는데 사용할 수 있다.
          영지식 <a>검증가능한 프레젠테이션</a>은 <a>보유자</a>가 공개하려 의도하지 않은 정보를 절대 공개해서는 안된다.

        </li>
      </ul>

      <p>
        다음 예는 영지식 <a>검증가능한 크리덴셜</a>을 사용하는 한 가지 방법을 보여 준다.
        CL 서명을 사용하여, <a>검증가능한 크리덴셜</a> 값의 선택적 공개를 통해
        <a>보유자</a>와 <a>주체</a>의 프라이버시를 지원하는 방식으로 <a>검증가능한 크리덴셜</a>을 제시할 수 있다.

      </p>

      <pre class="example nohighlight" title="CL 서명을 지원하는 검증가능한 크리덴셜">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  <span class="highlight">"credentialSchema": {
    "id": "did:example:cdf:35LB7w9ueWbagPL94T9bMLtyXDj9pX5o",
    "type": "did:example:schema:22KpkXgecryx9k7N6XN1QoN3gXwBkSU8SfyyYQG"
  }</span>,
  "issuer": "did:example:Wz4eUg7SetGfaUVCn8U9d62oDYrUJLuUtcy619",
  "credentialSubject": {
    "givenName": "Jane",
    "familyName": "Doe",
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts",
      "college": "College of Engineering"
    }
  },
  <span class="highlight">"proof": {
    "type": "CLSignature2019",
    "issuerData": "5NQ4TgzNfSQxoLzf2d5AV3JNiCdMaTgm...BXiX5UggB381QU7ZCgqWivUmy4D",
    "attributes": "pPYmqDvwwWBDPNykXVrBtKdsJDeZUGFA...tTERiLqsZ5oxCoCSodPQaggkDJy",
    "signature": "8eGWSiTiWtEA8WnBwX4T259STpxpRKuk...kpFnikqqSP3GMW7mVxC4chxFhVs",
    "signatureCorrectnessProof": "SNQbW3u1QV5q89qhxA1xyVqFa6jCrKwv...dsRypyuGGK3RhhBUvH1tPEL8orH"
  }</span>
}
        </pre>

      <p>
        위의 예는 <code>credentialSchema</code> <a>속성</a>과 Camenisch-Lysyanskaya 영지식 증명 시스템에서 사용할 수 있는
        특정 증명을 이용하여 <a>검증가능한 크리덴셜</a>의 정의를 제공한다.

      </p>

      <p>
        다음 예는 위의 <a>검증가능한 크리덴셜</a>을 사용하여 프라이버시 보호 증명이 포함된
        새로운 파생 <a>검증가능한 크리덴셜</a>을 생성한다.
        파생된 <a>검증가능한 크리덴셜</a>은 <a>검증가능한 프레젠테이션</a>에 배치되며, 이는 전체 주장이 유효함을 추가로 입증한다.
        <a>검증가능한 프레젠테이션</a>을 영지식 시스템에서 사용할 때 세 가지 요구사항이 있다.
      </p>

      <ul>
        <li>
          <a>검증가능한 프레젠테이션</a> 내에 있는 각각의 파생 <a>검증가능한 크리덴셜</a>은
          반드시 <code>credentialSchema</code> <a>속성</a>이 있어야 한다.
          이를 통해 파생 <a>검증가능한 크리덴셜</a>이 파생된 증명을 생성하는 데 사용된 크리덴셜의 정의를 참조할 수 있다.

        </li>
        <li>
          <a>검증가능한 프레젠테이션</a>은 <a>검증자</a>가 여러 개의 <a>검증가능한 프레젠테이션</a>을 통해
          <a>보유자</a>와 연관시킬 수 있는 정보를 절대 유출해서는 안된다.

        </li>
        <li>
          <a>검증가능한 프레젠테이션</a>은 <a>검증가능한 프레젠테이션</a>내에 있는
          모든 파생 <a>검증가능한 크리덴셜</a>이 동일한 <a>보유자</a>에게 발행되었음을 <a>검증자</a>가 확인할 수 있도록
          <a>보유자</a>가 공유하지 않는 개인 식별 정보 유출 없이 <code>proof</code> <a>속성</a>을 반드시 포함해야 한다.

        </li>
      </ul>

      <pre class="example nohighlight" title="CL 서명을 지원하는 검증가능한 프레젠테이션">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "type": "VerifiablePresentation",
  "verifiableCredential": [
    {
      "@context": [
        "https://www.w3.org/2018/credentials/v1",
        "https://www.w3.org/2018/credentials/examples/v1"
      ],
      "type": ["VerifiableCredential", "UniversityDegreeCredential"],
      <span class="highlight">"credentialSchema": {
        "id": "did:example:cdf:35LB7w9ueWbagPL94T9bMLtyXDj9pX5o",
        "type": "did:example:schema:22KpkXgecryx9k7N6XN1QoN3gXwBkSU8SfyyYQG"
      }</span>,
      "issuer": "did:example:Wz4eUg7SetGfaUVCn8U9d62oDYrUJLuUtcy619",
      "credentialSubject": {
        "degreeType": "BachelorDegree",
        "degreeSchool": "College of Engineering"
      },
      <span class="highlight">"proof": {
        "type": "AnonCredDerivedCredentialv1",
        "primaryProof": "cg7wLNSi48K5qNyAVMwdYqVHSMv1Ur8i...Fg2ZvWF6zGvcSAsym2sgSk737",
        "nonRevocationProof": "mu6fg24MfJPU1HvSXsf3ybzKARib4WxG...RSce53M6UwQCxYshCuS3d2h"
      }</span>
  }],
  <span class="highlight">"proof": {
    "type": "AnonCredPresentationProofv1",
    "proofValue": "DgYdYMUYHURJLD7xdnWRinqWCEY5u5fK...j915Lt3hMzLHoPiPQ9sSVfRrs1D"
  }</span>
}
        </pre>
      <figure>
        <img style="margin: auto; display: block; width: 75%;" src="diagrams/zkp-cred-pres.svg" alt="Verifiable
            Credential 1 and Verifiable Credential 2 on the left map
            to Derived Credential 1 and Derived Credential 2 inside a
            Presentation on the right.  Verifiable Credential 1
            contains Context, Type, ID, Issuer, Issue Date, Expiration
            Date, CredentialSubject, and Proof, where
            CredentialSubject contains GivenName, FamilyName, and
            Birthdate and Proof contains Signature, Proof of
            Correctness, and Attributes.  Verifiable Credential 2
            contains Context, Type, ID, Issuer, Issue Date, Expiration
            Date, CredentialSubject, and Proof, where
            CredentialSubject contains University, which contains
            Department, which contains DegreeAwarded, and Proof contains Signature, Proof of
            Correctness, and Attributes.  The Presentation diagram on
            the right contains Context, Type, ID,
            VerifiableCredential, and Proof, where
            VerifiableCredential contains Derived Credential 1 and
            Derived Credential 2 and Proof contains Common Link
            Secret.  Derived Credential 1 contains Context, Type, ID,
            Issuer, Issue Date, CredentialSubject, and Proof, where
            CredentialSubject contains AgeOver18 and Proof contains
            Knowledge of Signature.  Derived Credential 2 contains
            Context, Type, ID, Issuer, Issue Date, CredentialSubject,
            and Proof, where CredentialSubject contains Degree and
            Proof contains Knowledge of Signature.  A line links
            Birthdate in Verifiable Credential 1 to AgeOver18 in
            Derived Credential 1.  A line links DegreeAwarded in
            Verifiable Credential 2 to Degree in Derived Credential 2.">
        <figcaption style="text-align: center;">
          영지식 <a>프레젠테이션</a>에서 크리덴셜과 파생된 크리덴셜의 관계에 대한 시각적 예
        </figcaption>
      </figure>

      <p class="note">
        <a>크리덴셜</a> 정의의 형식 및 프루프에 대한 중요한 세부 정보는
        이 문서의 범위를 벗어나므로 의도적으로 생략되었다.
        이 섹션의 목적은 <a>검증가능한 크리덴셜</a>과 <a>검증가능한 프레젠테이션</a>을 확장하여
        영지식 증명 시스템을 지원하려는 구현자들을 안내하는 것이다.

      </p>

    </section>

    <section id="disputes">
      <h3>분쟁</h3>

      <p>
        <a>발급자</a>가 발급한 <a>크리덴셜</a>에 이의를 제기하려는 <a>개체</a>에 대하여 최소
        두 가지 경우를 고려해야한다:
      </p>

      <ul>
        <li>
          <a>주체</a>가 <a>발급자</a>가 발급한 크리덴셜에 대해 이의를 제기한다.
          예를 들어, <code>address</code> <a>속성</a>이 맞지 않거나 기한이 지났다.
        </li>
        <li>
          <a>개체</a>는 다른 주체에 대하여 <a>발급자</a>가 발급한 잠재적 허위 크리덴셜에 대해
          이의를 제기한다. 예를 들어, 공격자는 <a>개체</a>의 사회 보장 번호를 요구한다.
        </li>
      </ul>

      <p>
        <code>DisputeCredential</code>을 발급하는 메커니즘은 <code>DisputeCredential</code>
        <a>속성</a>의 <code>credentialSubject</code> 식별자가 이의를 제기하는
        <a>크리덴셜</a>의 식별자만 제외하면 일반 <a>크리덴셜</a>과 동일하다.
      </p>

      <p>
        예를 들어, 식별자가 <code>https://example.org/credentials/245</code>인
        <a>크리덴셜</a>에 이의가 있는 경우에 <a>주체</a>는 아래에 표시된 <a>크리덴셜</a>을
        발급하고, 이 <a>크리덴셜</a>의 이의를 제기한 <a>크리덴셜</a>과 함께 <a>검증자</a>에게 제시할 수 있다.
      </p>

      <pre class="example nohighlight" title="주체가 크리덴셜에 이의를 제기함">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.com/credentials/123",
  "type": ["VerifiableCredential", "DisputeCredential"],
  <span class="highlight">"credentialSubject": {
    "id": "http://example.com/credentials/245",
    "currentStatus": "Disputed",
    "statusReason": {
      "value": "Address is out of date.",
      "lang": "en"
    },
  }</span>,
  "issuer": "https://example.com/people#me",
  "issuanceDate": "2017-12-05T14:27:42Z",
  "proof": { <span class="comment">...</span> }
}
        </pre>

      <p>
        위의 <a>검증가능한 크리덴셜</a>에서 <a>발급자</a>는 이의 제기 가능한
        <a>검증가능한 크리덴셜</a>의 주소가 틀렸다고 주장한다.
      </p>

      <p class="note">
        <a>크리덴셜</a>에 식별자가 없는 경우 content-addressed 식별자를 사용하여 이의를
        제기한 <a>크리덴셜</a>을 식별할 수 있다. 유사하게 content-addressed 식별자는 개별
        요구사항을 고유하게 식별하는데 사용될 수 있다.
      </p>

      <p class="note">
        본 연구 영역은 빠르게 발전하고 있으며, 다른 <a>크리덴셜</a>의 정확성에 대해 이의를
        제기하는 <a>크리덴셜</a>을 발행하는데 관심이 있는 구현자는 검증가능한 크리덴셜
        구현 지침 [[VC-IMP-GUIDE]] 문서에서 분쟁과 관련된 부분을 읽어야 한다.
      </p>

    </section>

    <section class="informative" id="authorization">
      <h3>승인</h3>

      <p>
        <a>검증가능한 크리덴셜</a>은 <a>주체</a>에 대한 신뢰할 수 있는 신원증명의 수단으로 만들어졌다.
        역할 기반 접근 제어(Role Based Access Controls, RBACs)와 속성 기반 접근 제어(Attribute Based Access Controls, ABACs)는
        <a>주체</a>가 자원에 접근하는 것을
        승인하는 수단으로써 이 신원인증에 의존하는 것으로 인식되지만, 이 사양은 RBAC
        또는 ABAC를 위한 완전한 해결책을 제공하지는 않는다. 승인의 경우 승인 프레임워크 없이
        본 사양을 사용하는 것은 적절치 않다.
      </p>

      <p>
        워킹 그룹은 본 규격의 작성과정에서 인증의 사용 사례를 고려하였으며, 본 규격 위에
        구축된 구조적 계층으로서의 작업을 추구하고 있다.
      </p>
    </section>
  </section>

  <section id="syntaxes">
    <h2>구문</h2>

    <p>
      <a href="#core-data-model"></a>, <a href="#basic-concepts"></a>
      그리고 <a href="#advanced-concepts"></a>에서 설명한 데이터 모델은 <a>검증가능한 크리덴셜</a>
      또는 <a>검증가능한 프레젠테이션</a>의 규범적 구조적 표현이다. 모든 직렬화는
      특정 형식의 데이터 모델의 표현이다. 본 섹션에서는 데이터 모델이 JSON-LD와 일반 JSON에서
      실현되는 방식을 명시한다. 비록 이 두 구문에서만 구문적 매핑이 제공되지만, 데이터 모델을
      표현할 수 있는 기타 데이터 표현 구문(XML, YAML 또는 CBOR)도 사용할 수 있다. <a>검증</a>과 <a>유효성 검사</a>
      필요사항이 데이터 모델의 관점에서 정의되므로, 모든 직렬화 구문은 결정적으로 처리, <a>검증</a>
      또는 비교를 위한 데이터 모델로 변환되어야 한다. 본 사양은 어떠한 특정 직렬화 형식을
      지원하기 위한 요구사항을 만들지 않는다.
    </p>

    <p>
      본 사양에서 속성 값의 예상되는 아리티 및 그러한 값을 가지는 결과 데이터 타입은 속성에
      따라 변동될 수 있다. 만약 존재하는 경우, 다음과 같은 속성들은 단일 값으로 표현된다.
    </p>

    <ul>
      <li>
        <code>id</code> <a>속성</a>
      </li>
      <li>
        <code>issuer</code> <a>속성</a>
      </li>
      <li>
        <code>issuanceDate</code> <a>속성</a>
      </li>
      <li>
        <code>expirationDate</code> <a>속성</a>.
      </li>
    </ul>

    <p>
      다른 모든 속성들은, 만약 존재할 경우, 단일 값 또는 값의 배열로 표현된다.
    </p>

    <section>
      <h3>JSON</h3>

      <p>
        섹션 3. <a href="#core-data-model"></a>에서 설명한 것과 같이 데이터
        모델은 속성 값을 다음과 같은 JSON 타입에 매핑함으로써 Javascript Object Notation (JSON)
        [[!RFC8259]]으로 인코딩할 수 있다.
      </p>

      <ul>
        <li>
          IEEE754로 표현할 수 있는 숫자 값은 숫자 타입으로 표현해야만 한다.
        </li>
        <li>
          불리언 값은 불리언 타입으로 표현해야만 한다.
        </li>
        <li>
          시퀀스 값은 배열 타입으로 표현해야만 한다.
        </li>
        <li>
          순서가 없는 값의 집합은 배열 타입으로 표현해야만 한다.
        </li>
        <li>
          <a>속성</a>들의 집합은 오브젝트 타입으로 표현해야만 한다.
        </li>
        <li>
          빈 값은 널(null) 값으로 표현해야만 한다.
        </li>
        <li>
          다른 값들은 문자열 타입으로 표현해야만 한다.
        </li>
      </ul>

      <p class="note">
        여기 나열된 변환은 잠재적으로 양립할 수 없는 해석을 가지고 있으므로, 데이터 모델의
        결정론적 변환을 제공할 수 있으려면 추가적인 JSON 형식의 프로파일링이 필요하다.
      </p>

    </section>

    <section>
      <h3>JSON-LD</h3>

      <p>
        [[!JSON-LD]]는 <a href="http://www.w3.org/TR/ld-glossary/#linked-data">연결된 데이터</a>를
        직렬화하기 위해 사용되는 JSON기반의 형식이다. 해당 구문은
        이미 JSON을 사용하는 것으로 배포된 시스템에 쉽게 통합할 수 있도록 설계되었으며, JSON에서
        [[!JSON-LD]]로 부드럽게 업그레이드 할 수 있는 길을 제공한다. 이는 주로 웹 기반 프로그래밍
        환경에서 연결된 데이터를 사용하고, 상호 운용 가능한 웹 서비스를 구축하며, JSON 기반
        저장소 엔진에서 연결된 데이터를 저장하는 방식으로 사용한다.
      </p>

      <p>
        [[!JSON-LD]]는 본 사양에서 설명한 데이터 모델을 확장할 때 유용하다. 데이터 모델의
        인스턴스는 <code>@context</code> <a>속성</a>의 추가를 통해, JSON(섹션 <a href="#json"></a>)으로 인코딩되는 방식과 동일하게
        [[!JSON-LD]]로 인코딩된다. <a href="https://www.w3.org/TR/json-ld/#the-context">JSON-LD 컨텍스트</a>는
        [[!JSON-LD]] 사양에서 상세하게 설명되어 있고,
        그것의 사용은 섹션 <a href="#extensibility"></a>에서 상술하고 있다.
      </p>

      <p>
        관용적 JSON에서의 <a>검증가능한 크리덴셜</a>에 대한 임의의 정보를 표현하기 위해 다수의
        컨텍스트가 사용되거나 결합될 수 있다. <code>https://www.w3.org/2018/credentials/v1</code>
        에서 확인할 수 있는 <a href="https://www.w3.org/TR/json-ld/#the-context">JSON-LD 컨텍스트</a>는
        고정 문서로서 절대 업데이트 되지 않는다.
        따라서 클라이언트 사이드에 캐시하거나 다운로드 할 수 있다. 검증가능한 크리덴셜 데이터 모델에
        대한 연계된 용어 문서는 <code>https://www.w3.org/2018/credentials</code>에서 확인할 수 있다.
      </p>

      <section id="syntactic-sugar">
        <h3>신택틱 슈거(Syntactic Sugar)</h3>

        <p>
          일반적으로, 본 문서에서 설명하고있는 데이터 모델 및 구문은 개발자가 사례를 복사,
          붙여넣기 함으로써 자신의 소프트웨어 시스템에 <a>검증가능한 크리덴셜</a>을 포함할 수 있도록 설계되었다.
          이러한 접근의 디자인 목표는 이기종 소프트웨어 시스템 간 글로벌 상호 운용성을 보장하는 동시에
          진입장벽을 낮추는 것이다.
          본 섹션에서는 대부분의 개발자가 눈치채지 못할 수 있지만
          구현하는 사람에게는 관심이 있을 접근방식들에 대해 설명한다.
          [[!JSON-LD]]에서 가장 주목할만한 신택틱 슈거(Syntatic Sugars)는 아래와 같다.
        </p>

        <ul>
          <li>
            <code>@id</code>와 <code>@type</code> 키워드는
            각각 <code>id</code>와 <code>type</code>으로 구분되어,
            개발자가 이 규격을 관용적 JSON으로 사용할 수 있도록 한다.
          </li>
          <li>
            정수, 날짜, 측정단위, URL과 같은 데이터 타입은 자동으로 입력되어
            그것을 필요로 하는 사용 사례(Use Case)를 위한 강력한 타입 보장을 제공한다.
          </li>
          <li>
            <code>verifiableCredential</code>과 <code>proof</code> <a>속성</a>은
            <em>그래프 컨테이너(Graph Containers)</em>로 처리된다.
            이는 다른 개체가 주장하는 데이터 집합을 분리하는데 사용되는 메커니즘이다.
            이것은 각 <a>발급자</a>가 제공한 데이터 그래프와 각 그래프에 대한 유래를 보장하기 위해
            <a>검증가능한 크리덴셜</a>을 제시하는 <a>보유자</a>가 제공하는 정보 간의
            적절한 암호학적 구분을 보장한다.
          </li>
          <li>
            [[!JSON-LD]] 1.1의 <code>@protected</code> 속성 기능은
            본 규격에서 정의한 용어를 재정의할 수 없도록 하는데 사용된다.
            이는 동일한 <code>@context</code> 선언이
            <a>검증가능한 크리덴셜</a> 또는 <a>검증가능한 프레젠테이션</a>의 상단에서 이루어지는 한,
            [[!JSON-LD]] 프로세서의 사용 여부와 상관없이
            사용자가 이해한 모든 용어에 대한 상호운용성을 보장한다는 의미이다.
          </li>
        </ul>
      </section>

    </section>

    <section id="proof-formats">
      <h2>프루프 형식</h2>

      <p>
        이 규격에 기술된 데이터 모델은 증명 형식에 구애받지 않도록 설계되었다. 
        이 규격은 특정한 디지털 증명이나 서명 형식을 표준으로 요구하지 않는다. 
        데이터 모델은 <a>검증가능한 크리덴셜</a> 또는 <a>검증가능한 프레젠테이션</a>의 규범적 표현이지만, 
        이들의 입증 메커니즘은 종종 당사자 사이의 문서 전송에 사용되는 구문과 관련이 있다. 
        이와 같이 각 증명 메커니즘은 전송되는 문서의 상태에 대해, 변환된 데이터 모델을 기준으로 또는 다른 양식에 대해 검증이 계산되는지 여부를 명시해야 한다. 
        출판 당시, 적어도 두 개의 증명 형식이 구현자에 의해 활발하게 사용되고 있으며 작업 그룹은 이러한 증명 형식이 무엇이고 
        어떻게 사용되고 있는지를 문서화하는 것이 구현자에게 유익할 것이라고 생각했다. 
        <a>검증가능한 크리덴셜</a>을 발급하기 위해 적극적으로 활용되고 있는 현재 증명 형식을 상세히 기술하는 섹션은 다음과 같다.

      </p>

      <ul>
        <li>Section <a href="#json-web-token"></a>,</li>
        <li>Section <a href="#linked-data-proofs"></a>.</li>
      </ul>

      <section id="json-web-token">
        <h3>JSON Web Token</h3>

        <p>
          JSON Web Token (JWT) [RFC7519]은 여전히 두 당사자 간에 전달되는 <a>클레임</a>을 표현하기 위해
          널리 사용되는 수단이다. JWT에 대한 검증가능한 크리덴셜 데이터 모델을 제공함으로써
          기존 시스템과 라이브러리가 섹션 <a href="#ecosystem-overview"></a>에 설명된 생태계에 참여할 수 있다.
          JWT는 일련의 <a>클레임</a> JSON Web Signature (JWS) [RFC7515] 또는 JWE [RFC7516]에
          포함된 JSON 개체로 인코딩한다. 이 규격에서 JWE의 사용은 범위를 벗어나므로 다루지 않는다.
        </p>

        <section id="relation-to-the-verifiable-credentials-data-model">
          <h4>검증가능한 크리덴셜 데이터 모델과의 관계</h4>

          <p>
            이 규격은 검증가능한 크리덴셜 데이터 모델의 인코딩 규칙을 JWT 및 JWS에 정의한다.
            또한 JWT에 기초한 시스템이 이 규격을 준수할 수 있도록 특정 JWT 형식에
            등록된 <a>클레임</a>의 이름과 특정 JWS 등록 헤더 파라미터 이름을
            언제 어떻게 사용하는지를 정의한다.
            이러한 특정 <a>클레임</a>의 이름과 헤더 파라미터가 존재하는 경우,
            그에 대응되는 표준 <a>검증가능한 크리덴셜</a>과 <a>검증가능한 프레젠테이션</a>은 중복 방지를 위해 생략될 수 있다.
          </p>
        </section>

        <section id="json-web-token-extentions">
          <h4>JSON Web Token 익스텐션</h4>

          <p>
            이 규격은 JWT에 대한 명시적 인코딩 규칙이 존재하지 않는
            표준 <a>검증가능한 크리덴셜</a> 및 <a>검증가능한 프레젠테이션</a>의 일부를 포함하는
            새로 등록된 두 개의 <a>클레임</a>의 이름에 대해 소개한다.
            이러한 객체들은 다음과 같이 JWT 전송 데이터에 포함되어있다:
          </p>

          <ul>
            <li>
              <code>vc</code>: JWT 형식의 <a>검증가능한 크리덴셜</a>에 반드시 있어야 하는 JSON 개체.
              객체는 이 규격을 따른 <a>검증가능한 크리덴셜</a>을 포함한다.

            </li>
            <li>
              <code>vp</code>: JWT <a>검증가능한 프레젠테이션</a>에 반드시 있어야 하는 JSON 객체.
              객체는 이 규격에 따라 <a>검증가능한 프레젠테이션</a>을 포함한다
            </li>
          </ul>
        </section>

        <section id="jwt-and-jws-considerations">
          <h4>JWT and JWS 고려사항</h4>

          <section id="jwt-encoding">
            <h5>JWT 인코딩</h5>

            <p>
              <a>검증가능한 크리덴셜</a>을 JWT로 인코딩하려면
              이 규격에 의해 명시된 특정 <a>속성</a>은 다음 중 한가지 조건을 만족해야 한다.
            </p>

            <ul>
              <li>
                표준 JOSE 헤더 파라미터로 인코딩, 또는
              </li>
              <li>
                등록된 JWT <a>클레임</a> 이름으로 인코딩, 또는
              </li>
              <li>
                JWS 서명 부분에 포함
              </li>
            </ul>

            <p>

              명시적 규칙이 지정되지 않은 경우 <a>속성</a>들은 표준 <a>검증가능한 크리덴셜</a>과 동일한 방식으로 인코딩되며
              JWT의 <code>vc</code> <a>클레임</a>에 추가된다. 모든 JWT와 마찬가지로, JWT 구문에 표시된 <a>검증가능한 크리덴셜</a>의
              JWS 기반 서명은 디코딩 또는 변환 규칙 적용 전의 JWT 문자열 값에 대해 계산된다.
              다음 단락은 이러한 인코딩 규칙을 설명한다.

            </p>

            <p>

              JWS가 존재하는 경우, 디지털 서명은 <a>검증가능한 크리덴셜</a>의 <a>발급자</a>를 입증하거나,
              <a>검증가능한 프레젠테이션</a>의 경우, <a>검증가능한 크리덴셜</a>의 <a>보유자</a>를 입증한다.
              JWS는 JWT의 <a>발급자</a>가 JWT 페이로드에 서명했음을 증명한다. 따라서 <code>proof</code> <a>속성</a>은 생략될 수 있다.

            </p>

            <p>
              JWS가 없는 경우 반드시 <code>proof</code> <a>속성</a>을 제공해야 한다.
              <code>proof</code> <a>속성</a>은 작성자가 <a>발급자</a>와 다른 경우에 필요할 수 있고,
              작업 증명과 같은 디지털 서명에 근거하지 않은 증명을 나타내기 위해 사용될 수 있다.
              <a>발급자</a>는 <a>검증가능한 크리덴셜</a>에 JWS와 <code>proof</code> <a>속성</a>을 모두 포함할 수 있다.
              하지만 역호환성을 고려한다면 발급자는 JWS를 사용하여 디지털 서명에 기반한 증명을 나타내야 한다.
            </p>

            <p>
              다음 규칙은 이 규격의 context에서 JOSE 헤더에 적용된다.</p>

            <ul>
              <li>
                <code>alg</code>는 디지털 서명을 위해 반드시 설정되어야 한다.
                선택한 서명 방법에 <code>proof</code> <a>속성</a>만 필요한 경우(즉, 해당 메소드 내에 선택한 알고리즘이 없는경우)
                <code>alg</code> 헤더를 <code>none</code>으로 설정해야 한다.
              </li>

              <li>
                JWT <a>발급자</a>와 관련된 키가 여러 개 있는 경우 <code>kid</code>를 사용할 수 있다.
                주요 과정은 이 규격의 범위를 벗어난다.
                예를 들어, <code>kid</code>는 <a>DID 문서</a>의 키를 참조하거나 JWKS 내부의 키 식별자가 될 수 있다.

              </li>
              <li>
                <code>typ</code>가 있는 경우 <code>JWT</code>로 설정해야 함

              </li>
            </ul>

            <p>
              JWT 프로세서와의 역호환성을 위해,
              다음의 JWT 형식에 등록된 클레임 명칭은 반드시 각각에 대응되는 표준 <a>검증가능한 크리덴셜</a> 대신,
              또는 추가로 사용되어야 한다.

            </p>

            <ul>
              <li>
                <code>exp</code>는 <code>expirationDate</code> <a>속성</a>을 나타내야 하고
                UNIX 타임스탬프(<code>NumericDate</code>)로 인코딩되어야 한다.
              </li>
              <li>
                <code>iss</code>는 반드시 <a>검증가능한 크리덴셜</a>의 <code>issuer</code> <a>속성</a>
                또는 <a>검증가능한 프레젠테이션</a>의 <code>holder</code> <a>속성</a>을 나타내야 한다.

              </li>
              <li>
                <code>nbf</code>는 반드시 <code>issuanceDate</code>를 나타내야하고,
                UNIX 타임스탬프(<code>NumericDate</code>)로 인코딩되어야 한다.

              </li>
              <li>
                <code>jti</code>는 반드시 <a>검증가능한 크리덴셜</a> 또는 <a>검증가능한 프레젠테이션</a>의
                <code>id</code> <a>속성</a>을 나타내야 한다.

              </li>
              <li>
                <code>sub</code>는 반드시 <a>검증가능한 크리덴셜</a> <a>주체</a>에 포함된 <code>id</code> <a>속성</a>을 나타내야 한다.

              </li>
              <li>
                <code>aud</code>는 반드시 <a>검증가능한 프레젠테이션</a>의 의도된 대상
                (즉, 프레젠테이션 보유자가 <a>검증가능한 프레젠테이션</a>을 수신하고 검증하도록 의도된 <a>검증자</a>)을
                나타내야 한다.(즉, 식별하다)
              </li>
            </ul>

            <p>
              명시적으로 사용이 금지되어있지 않다면
              본 문서에 명시되지 않은 다른 JOSE 헤더 매개변수 및 JWT 클레임 이름을 사용할 수 있다.
              추가적인 <a>검증가능한 크리덴셜</a> <a>클레임</a>은 JWT의 <code>credentialSubject</code> 속성에 추가되어야 한다.

            </p>

            <p>
              여기에 지정되지 않은 JOSE 헤더 매개 변수 및/또는 JWT 클레임 이름 사용에 대한
              자세한 내용은 검증가능한 크리덴셜 구현 지침 [[?VC-IMP-GUIDE]] 문서를 참조.
            </p>

            <p>
              이 규격 버전은 섹션 <a href="#advanced-concepts">고급 개념</a>
              (예: <code>refreshService</code>, <code>termsOfUse</code> 및 <code>evidence</code>)에 요약된 개념에 대한
              JWT별 인코딩 규칙을 정의하지 않는다.
              이러한 개념은 별도의 변환 없이 그대로 인코딩할 수 있으며,
              JWT의 <code>vc</code> <a>클레임</a>에 추가될 수 있다.
            </p>

            <p class="note">

              구현자는 JWT가 복수의 <a>주체</a>들을 인코딩할 수 없고,
              따라서 <a>검증가능한 크리덴셜</a>을 둘 이상의 <a>주체</a>와 인코딩할 수 없다는 경고를 받는다.
              JWT는 향후 여러 주제를 지원할 수 있으며,
              구현자는 다중 주체 JWT 클레임 명칭에 대한 <a href="https://www.iana.org/assignments/jwt/">
                JSON Web Token Claim Registry</a>
              또는 <a href="https://tools.ietf.org/html/draft-yusef-oauth-nested-jwt-00">
                Nested JSON Web Token</a> 규격을 참조할 것을 권고한다.

            </p>

          </section>

          <section id="jwt-decoding">
            <h5>JWT 디코딩</h5>

            <p>
              JWT를 표준 <a>검증가능한 크리덴셜</a>으로 디코딩하려면 다음 변환을 수행해야 한다.
            </p>

            <ol>
              <li>
                JSON 객체를 생성.
              </li>
              <li>
                <code>vc</code> <a>클레임</a>의 내용을 새 JSON 객체에 추가.

              </li>
              <li>
                나머지 JWT 특정 헤더 및 <a>클레임</a>을 변환하고 결과를 새 JSON 객체에 추가.
              </li>
            </ol>

            <p>
              JWT 특정 헤더 및 <a>클레임</a>을 변환하려면 반드시 다음 작업을 수행.

            </p>

            <ul>
              <li>

                <code>exp</code>의 경우 UNIX 타임스탬프는 [[!RFC3339]] <code>date-time</code>으로 변환해야 하며,
                새 JSON 객체의 <code>credentialSubject</code> <code>expirationDate</code> <a>속성</a> 값을 설정하는 데 사용해야 한다.


              </li>
              <li>
                <code>iss</code>의 경우,
                새로운 검증가능한 크리덴셜 JSON 개체의 <code>issuer</code> <a>속성</a>이나
                새로운 검증가능한 프레젠테이션 JSON 개체의 <code>holder</code> <a>속성</a>을 설정하는 데 이 값을 사용해야 한다.

              </li>
              <li>

                <code>nbf</code>의 경우 UNIX 타임스탬프는 [[!RFC3339]] <code>date-time</code>으로 변환해야 하며,
                새로운 JSON 개체의 <code>issuanceDate</code> <a>속성</a> 값을 설정하는 데 사용해야 한다.

              </li>
              <li>
                <code>sub</code>의 경우 이 값을 사용하여 새 JSON 개체의
                <code>credentialSubject</code>의 <code>id</code> <a>속성</a> 값을 설정해야 한다.


              </li>
              <li>

                <code>jti</code>의 경우 값은 반드시 새 JSON 객체의 <code>id</code> <a>속성</a> 값을 설정하여 사용해야 한다.
              </li>
            </ul>

            <pre class="example nohighlight" title="JWS를 증명으로 사용하는 JWT 기반 검증가능한 크리덴셜의 JWT 헤더 (비표준)">
{
    "alg": "RS256",
    "typ": "JWT",
    "kid": "did:example:abfe13f712120431c276e12ecab#keys-1"
}
            </pre>

            <p>

              위의 예에서 <a>검증가능한 크리덴셜</a>은 <code>JWS</code> 전자 서명을 기반으로 하는 <code>proof</code>를 사용하며,
              해당 <a>검증</a> 키는 <code>kid</code> 헤더 매개변수를 사용하여 얻을 수 있다.

            </p>

            <pre class="example nohighlight" title="JWS를 증명으로 사용하는 JWT 기반 검증가능한 크리덴셜의 JWT 페이로드 (비표준)">
{
  "sub": "did:example:ebfeb1f712ebc6f1c276e12ec21",
  "jti": "http://example.edu/credentials/3732",
  "iss": "https://example.com/keys/foo.jwk",
  "nbf": 1541493724,
  "iat": 1541493724,
  "exp": 1573029723,
  "nonce": "660!6345FSer",
  "vc": {
    "@context": [
      "https://www.w3.org/2018/credentials/v1",
      "https://www.w3.org/2018/credentials/examples/v1"
    ],
    "type": ["VerifiableCredential", "UniversityDegreeCredential"],
    "credentialSubject": {
      "degree": {
        "type": "BachelorDegree",
        "name": "Bachelor of Science and Arts"
      }
    }
  }
}
            </pre>

            <p>
              위의 예시에서 <code>JWT</code> 인코딩은 고유한 식별자를 나타내기 위해
              <code>jti</code> 속성을 사용하기 때문에 <code>vc</code>는 <code>id</code>
              <a>속성</a>을 포함하지 않는다.
              <code>sub</code> 속성은 <code>credentialSubject</code>의 <code>id</code> <a>속성</a>으로 표시되는 정보를 인코딩한다.

            </p>

            <pre class="example nohighlight" title="JWT 콤팩트 직렬화를 사용한 검증가능한 크리덴셜 (비표준)">
eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImRpZDpleGFtcGxlOmFiZmUxM2Y3MTIxMjA0
MzFjMjc2ZTEyZWNhYiNrZXlzLTEifQ.<span class="highlight">eyJzdWIiOiJkaWQ6ZXhhbXBsZTplYmZlYjFmNzEyZWJjNmYxY
zI3NmUxMmVjMjEiLCJqdGkiOiJodHRwOi8vZXhhbXBsZS5lZHUvY3JlZGVudGlhbHMvMzczMiIsImlzc
yI6Imh0dHBzOi8vZXhhbXBsZS5jb20va2V5cy9mb28uandrIiwibmJmIjoxNTQxNDkzNzI0LCJpYXQiO
jE1NDE0OTM3MjQsImV4cCI6MTU3MzAyOTcyMywibm9uY2UiOiI2NjAhNjM0NUZTZXIiLCJ2YyI6eyJAY
29udGV4dCI6WyJodHRwczovL3d3dy53My5vcmcvMjAxOC9jcmVkZW50aWFscy92MSIsImh0dHBzOi8vd
3d3LnczLm9yZy8yMDE4L2NyZWRlbnRpYWxzL2V4YW1wbGVzL3YxIl0sInR5cGUiOlsiVmVyaWZpYWJsZ
UNyZWRlbnRpYWwiLCJVbml2ZXJzaXR5RGVncmVlQ3JlZGVudGlhbCJdLCJjcmVkZW50aWFsU3ViamVjd
CI6eyJkZWdyZWUiOnsidHlwZSI6IkJhY2hlbG9yRGVncmVlIiwibmFtZSI6IjxzcGFuIGxhbmc9J2ZyL
UNBJz5CYWNjYWxhdXLDqWF0IGVuIG11c2lxdWVzIG51bcOpcmlxdWVzPC9zcGFuPiJ9fX19</span>.KLJo5GAy
BND3LDTn9H7FQokEsUEi8jKwXhGvoN3JtRa51xrNDgXDb0cq1UTYB-rK4Ft9YVmR1NI_ZOF8oGc_7wAp
8PHbF2HaWodQIoOBxxT-4WNqAxft7ET6lkH-4S6Ux3rSGAmczMohEEf8eCeN-jC8WekdPl6zKZQj0YPB
1rx6X0-xlFBs7cl6Wt8rfBP_tZ9YgVWrQmUWypSioc0MUyiphmyEbLZagTyPlUyflGlEdqrZAv6eSe6R
txJy6M1-lD7a5HTzanYTWBPAUHDZGyGKXdJw-W_x0IWChBzI8t3kpG253fg6V3tPgHeKXE94fz_QpYfg
--7kLsyBAfQGbg
            </pre>

            <pre class="example nohighlight" title="JWT기반 검증가능한 프레젠테이션의 JWT 헤더 (비표준)">
{
  "alg": "RS256",
  "typ": "JWT",
  "kid": "did:example:ebfeb1f712ebc6f1c276e12ec21#keys-1"
}
            </pre>

            <p>
              위의 예시에서 <a>검증가능한 프레젠테이션</a>은
              <code>JWS</code> 디지털 서명에 기초한 <code>proof</code>를 사용하며,
              해당 <a>검증</a> 키는 <code>kid</code> 헤더 매개변수를 사용하여 얻을 수 있다.

            </p>

            <pre class="example nohighlight" title="JWT기반 검증가능한 프레젠테이션의 JWT 페이로드 (비표준)">
{
  "iss": "did:example:ebfeb1f712ebc6f1c276e12ec21",
  "jti": "urn:uuid:3978344f-8596-4c3a-a978-8fcaba3903c5",
  "aud": "did:example:4a57546973436f6f6c4a4a57573",
  "nbf": 1541493724,
  "iat": 1541493724,
  "exp": 1573029723,
  "nonce": "343s$FSFDa-",
  "vp": {
    "@context": [
      "https://www.w3.org/2018/credentials/v1",
      "https://www.w3.org/2018/credentials/examples/v1"
    ],
    "type": ["VerifiablePresentation"],
    <span class="comment">// base64url-encoded JWT as string</span>
    "verifiableCredential": ["<span class="comment">...</span>"]
  }
}
            </pre>

            <p>

              위의 예시 에서 <code>JWT</code> 인코딩은 고유한 식별자를 나타내기 위해
              <code>jti</code> 속성을 사용하기 때문에 <code>vp</code>는 <code>id</code>
              <a>속성</a>을 포함하지 않는다.
              <code>verifiableCredential</code>에는 <code>JWT</code> 콤팩트 직렬화를 사용하는
              <a>검증가능한 크리덴셜</a>의 문자열이 포함되어 있다.
            </p>

            <pre class="example nohighlight" title="JWT 콤팩트 직렬화를 사용한 검증가능한 프레젠테이션 (비표준)">

eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImRpZDpleGFtcGxlOjB4YWJjI2tleTEifQ.<span class="highlight">e
yJpc3MiOiJkaWQ6ZXhhbXBsZTplYmZlYjFmNzEyZWJjNmYxYzI3NmUxMmVjMjEiLCJqdGkiOiJ1cm46d
XVpZDozOTc4MzQ0Zi04NTk2LTRjM2EtYTk3OC04ZmNhYmEzOTAzYzUiLCJhdWQiOiJkaWQ6ZXhhbXBsZ
To0YTU3NTQ2OTczNDM2ZjZmNmM0YTRhNTc1NzMiLCJuYmYiOjE1NDE0OTM3MjQsImlhdCI6MTU0MTQ5M
zcyNCwiZXhwIjoxNTczMDI5NzIzLCJub25jZSI6IjM0M3MkRlNGRGEtIiwidnAiOnsiQGNvbnRleHQiO
lsiaHR0cHM6Ly93d3cudzMub3JnLzIwMTgvY3JlZGVudGlhbHMvdjEiLCJodHRwczovL3d3dy53My5vc
mcvMjAxOC9jcmVkZW50aWFscy9leGFtcGxlcy92MSJdLCJ0eXBlIjpbIlZlcmlmaWFibGVQcmVzZW50Y
XRpb24iLCJDcmVkZW50aWFsTWFuYWdlclByZXNlbnRhdGlvbiJdLCJ2ZXJpZmlhYmxlQ3JlZGVudGlhb
CI6WyJleUpoYkdjaU9pSlNVekkxTmlJc0luUjVjQ0k2SWtwWFZDSXNJbXRwWkNJNkltUnBaRHBsZUdGd
GNHeGxPbUZpWm1VeE0yWTNNVEl4TWpBME16RmpNamMyWlRFeVpXTmhZaU5yWlhsekxURWlmUS5leUp6Z
FdJaU9pSmthV1E2WlhoaGJYQnNaVHBsWW1abFlqRm1OekV5WldKak5tWXhZekkzTm1VeE1tVmpNakVpT
ENKcWRHa2lPaUpvZEhSd09pOHZaWGhoYlhCc1pTNWxaSFV2WTNKbFpHVnVkR2xoYkhNdk16Y3pNaUlzS
W1semN5STZJbWgwZEhCek9pOHZaWGhoYlhCc1pTNWpiMjB2YTJWNWN5OW1iMjh1YW5kcklpd2libUptS
WpveE5UUXhORGt6TnpJMExDSnBZWFFpT2pFMU5ERTBPVE0zTWpRc0ltVjRjQ0k2TVRVM016QXlPVGN5T
Xl3aWJtOXVZMlVpT2lJMk5qQWhOak0wTlVaVFpYSWlMQ0oyWXlJNmV5SkFZMjl1ZEdWNGRDSTZXeUpvZ
EhSd2N6b3ZMM2QzZHk1M015NXZjbWN2TWpBeE9DOWpjbVZrWlc1MGFXRnNjeTkyTVNJc0ltaDBkSEJ6T
2k4dmQzZDNMbmN6TG05eVp5OHlNREU0TDJOeVpXUmxiblJwWVd4ekwyVjRZVzF3YkdWekwzWXhJbDBzS
W5SNWNHVWlPbHNpVm1WeWFXWnBZV0pzWlVOeVpXUmxiblJwWVd3aUxDSlZibWwyWlhKemFYUjVSR1ZuY
21WbFEzSmxaR1Z1ZEdsaGJDSmRMQ0pqY21Wa1pXNTBhV0ZzVTNWaWFtVmpkQ0k2ZXlKa1pXZHlaV1VpT
25zaWRIbHdaU0k2SWtKaFkyaGxiRzl5UkdWbmNtVmxJaXdpYm1GdFpTSTZJanh6Y0dGdUlHeGhibWM5S
jJaeUxVTkJKejVDWVdOallXeGhkWExEcVdGMElHVnVJRzExYzJseGRXVnpJRzUxYmNPcGNtbHhkV1Z6U
EM5emNHRnVQaUo5ZlgxOS5LTEpvNUdBeUJORDNMRFRuOUg3RlFva0VzVUVpOGpLd1hoR3ZvTjNKdFJhN
TF4ck5EZ1hEYjBjcTFVVFlCLXJLNEZ0OVlWbVIxTklfWk9GOG9HY183d0FwOFBIYkYySGFXb2RRSW9PQ
nh4VC00V05xQXhmdDdFVDZsa0gtNFM2VXgzclNHQW1jek1vaEVFZjhlQ2VOLWpDOFdla2RQbDZ6S1pRa
jBZUEIxcng2WDAteGxGQnM3Y2w2V3Q4cmZCUF90WjlZZ1ZXclFtVVd5cFNpb2MwTVV5aXBobXlFYkxaY
WdUeVBsVXlmbEdsRWRxclpBdjZlU2U2UnR4Snk2TTEtbEQ3YTVIVHphbllUV0JQQVVIRFpHeUdLWGRKd
y1XX3gwSVdDaEJ6STh0M2twRzI1M2ZnNlYzdFBnSGVLWEU5NGZ6X1FwWWZnLS03a0xzeUJBZlFHYmciX
X19</span>.ft_Eq4IniBrr7gtzRfrYj8Vy1aPXuFZU-6_ai0wvaKcsrzI4JkQEKTvbJwdvIeuGuTqy7ipO-EYi
7V4TvonPuTRdpB7ZHOlYlbZ4wA9WJ6mSVSqDACvYRiFvrOFmie8rgm6GacWatgO4m4NqiFKFko3r58Lu
eFfGw47NK9RcfOkVQeHCq4btaDqksDKeoTrNysF4YS89INa-prWomrLRAhnwLOo1Etp3E4ESAxg73CR2
kA5AoMbf5KtFueWnMcSbQkMRdWcGC1VssC0tB0JffVjq7ZV6OTyV4kl1-UVgiPLXUTpupFfLRhf9QpqM
BjYgP62KvhIvW8BbkGUelYMetA
            </pre>

          </section>
        </section>
      </section>

      <section id="linked-data-proofs">
        <h3>연결된 데이터 프루프들</h3>

        <p>
          이 규격은 Linked Data를 이용하여 URL, JSON-LD와 같은 표준을 사용하여
          웹에 정보를 게시하여 <a>주체</a>와 관련 속성을 식별한다.
          이러한 방식으로 정보를 제시하면 다른 관련 정보를 쉽게 발견할 수 있고
          새로운 정보를 기존의 지식 그래프로 쉽게 통합할 수 있다.
          Linked Data는 분산된 방식으로 확장 가능하여 대규모 통합에 대한 장벽을 크게 줄인다.
          이 규격의 데이터 모델은 이 규격에 설명된 대로 데이터 모델을 보호하도록 설계된
          <a href="https://w3c-dvcg.github.io/ld-proofs/">Linked Data Proofs</a>,
          <a href="https://w3c-dvcg.github.io/ld-signatures/">Linked Data Signatures</a> 및
          관련 <a href="https://w3c-ccg.github.io/ld-cryptosuite-registry/">Linked Data Cryptographic Suites</a>와 잘 작동한다.


        </p>

        <p>
          JSON Web Token의 사용과 달리 별도의 사전 또는 후처리는 필요하지 않다.
          Linked Data Proofs 형식은 <a>검증가능한 크리덴셜</a>과 <a>검증가능한 프레젠테이션</a>을
          간단하고 쉽게 보호하도록 설계되었다. <a>검증가능한 크리덴셜</a> 또는
          <a>검증가능한 프레젠테이션</a>을 보호하는 것은 이 규격의 유효한 예를
          Linked Data Signatures 구현에 전달하고 디지털 서명을 생성하는 것만큼 간단하다.

        </p>

        <p class="note">
          다양한 syntax 형식(예: JSON+JWT, JSON-LD+JWT 또는 JSON-LD+LD-Proofs)의 다양한 품질에 대한 자세한 내용은
          검증가능한 크리덴셜 구현 지침 [[VC-IMP-GUIDE]] 문서를 참조.
        </p>

      </section>

    </section>
  </section>
  </section>

  <section class="informative" id="privacy-considerations">
    <h2>프라이버시 고려사항들</h2>

    <p>
      이 섹션에서는 검증가능한 크리덴셜 데이터 모델을
      프로덕션 환경에 배포할 때의
      일반적인 프라이버시 고려사항 및 특정 프라이버시 관련 영향에 대해 자세히 설명한다.

    </p>

    <section class="informative" id="spectrum-of-privacy">
      <h3>프라이버시의 범주</h3>

      <p>
        익명부터 강하게 식별되는 범위에 이르는 프라이버시의 범주가 있음을 인지하는 것은 중요하다.
        사례에 의하면, 사람들은 제공하고자하는 정보와 제공되는 정보에서 파생된 정보에 대해 서로 다른 안도감의 단계를 가지고 있다
      </p>

      <figure>
        <img style="margin: auto; display: block; width: 80%;" src="diagrams/privacy-spectrum.svg" alt="Horizontal bar with
          red on the left, orange in the middle, and green on the
          right.  The red has the text 'Highly correlatable (global
          IDs), e.g., government ID, shipping address, credit card
          number'.  The orange has the text 'Correlatable ia collusion
          (personally identifiable info), e.g., name, birthday, zip
          code'.  The green has the text 'Non-correlatable
          (pseudonyms), e.g., age over 21'.">
        <figcaption style="text-align: center;">
          익명부터 완전히 식별되는 범위에 이르는 프라이버시의 범주
        </figcaption>
      </figure>

      <p>
        예를 들어, 대부분의 사람들은 주류를 구입할 때 익명을 유지하기를 원하는데 그 이유는 필요한 규제 확인은 전적으로 그 사람이 특정 연령 이상인지 여부에 달려있기 때문이다. 그 대신, 의사가 환자를 위해
        작성한 의료 처방전의 경우, 처방을 이행하는 약국은 의료 전문자와 환자를 강하게 식별해야 한다. 따라서 모든 사례에 적합한 하나의 프라이버시 접근법은 없다. 프라이버시 해결책은 사례에 따라 다르다.
      </p>

      <p class="note">
        주류를 구입할 때 익명을 유지하려는 경우에도, 상인에게 적절한 보증을 제공하기 위해 사진 신분증이 필요할 수 있다. 상인은 (당신이 특정 연령 이상이라는 것 이외에) 당신의 이름이나 다른 세부 정보를
        알 필요가 없지만, 많은 경우 나이 증명은 규정을 충족하기에 아직 불충분하다.
      </p>

      <p>
        검증가능한 크리덴셜 데이터 모델은 전체 프라이버시 범주를 지원하기 위해 노력하고 있으며, 어떤 특정 트랜잭션에 대해서도 올바른 수준의 익명성에 대한 철학적 입장을 취하지 않는다. 다음 섹션은
        프라이버시에 적대적인 특정 시나리오들을 피하려는 구현자들을 위한 지침을 제공한다.
      </p>
    </section>

    <section class="informative" id="personally-identifiable-information">
      <h3>개인식별정보</h3>

      <p>
        <code>credential.credentialSubject</code> 필드에 저장된 <a>검증가능한 크리덴셜</a> 관련 데이터는
        <a>검증자</a>와 공유할 경우 프라이버시 침해를 허용할 수 있다. 정부에서 발행한 식별자,
        배송지 주소, 성명 등과 같은 개인식별정보는 <a>개체</a>를 특정하거나 추적하고 상관관계를
        확인하는데 쉽게 사용될 수 있다. 비록 생일과 우편번호의 조합 같이 개인을 식별별하는데
        쓸 수 없을 것 같은 정보라도 매우 강력한 상관관계 및 재식별화(De-anonymizing)의
        가능성을 가지고 있다.
      </p>

      <p>
        구현자는 이러한 종류의 특성을 가진 데이터를 공유할 경우 <a>보유자</a>에게 경고할 것을 강력하게
        권고한다. <a>발급자</a>는 가능하면 프라이버시를 보호하는 <a>검증가능한 크리덴셜</a>을 제공할 것을
        강력하게 권고한다. 예를들면, <a>검증자</a>가 <a>개체</a>의 성인 여부를 확인하고자 하면, 생년월일을
        담은 <a>검증가능한 크리덴셜</a>을 발행하는 대신 <code>ageOver</code> <a>검증가능한 크리덴셜</a>을 발행하는 것이다.
      </p>

      <p>
        <a>검증가능한 크리덴셜</a>은 종종 개인식별정보(PII)를 포함하고 있기 때문에, 구현자는
        <a>검증가능한 크리덴셜</a>을 저장하고 전송하는 과정에서 접근하지 말아야 할 사람들로부터
        데이터를 보호하기 위한 메커니즘을 사용하도록 해야 한다. 고려할 수 있는 매커니즘은
        전송계층보안(TLS, Transport Layer Security) 또는 그 외에 데이터 전송시에는 데이터를
        암호화하고 전송 중이 아니더라도 <a>검증가능한 크리덴셜</a>의 데이터를 암호화하거나 접근
        제어하는 수단이 있을 수 있다.
      </p>
    </section>

    <section class="informative" id="identifier-based-correlation">
      <h3>식별자 기반 상관관계</h3>

      <p>
        <a>검증가능한 크리덴셜</a>의 <a>주체</a>는 <code>credential.credentialSubject.id</code> 필드를 사용하여
        식별된다. <a>주체</a>를 식별하기 위해 사용되는 식별자는 식별자의 수명이 길고 하나 이상의
        웹 도메인을 넘나들며 사용될 경우 더 큰 상관관계의 위험을 야기한다.
      </p>

      <p>
        유사하게, <a>크리덴셜</a> 식별자(<code>credential.id</code>)를 공개하는 것은러 <a>검증자</a>가 결탁하거나
        혹은 <a>발급자</a>와 <a>검증자</a>가 결탁하여 <a>보유자</a>와의 상관관계를 파악할 수 있는 상황으로 이끌
        수 있다. 만약 <a>보유자</a>가 상관관계를 줄이고 싶다면, <a>검증가능한 프레젠테이션</a>을 하는 동안
        식별자를 숨기는 <a>검증가능한 크리덴셜</a> 스킴을 사용해야 한다. 그러한 스킴은 <a>보유자</a>가
        식별자를 생성하고 사용자로부터 식별자를 숨기는 것을 허용하는 한편 식별자를 <a>검증가능한 크리덴셜</a>
        안에 포함하고 서명할 수 있도록 유지한다.
      </p>

      <p>
        만약 강력한 상관관계 방지 속성이 요구되는 <a>검증가능한 크리덴셜</a> 체계인 경우, 식별자는
        다음 중 하나를 만족하도록 강력히 권고된다:
      </p>

      <ul>
        <li>
          단일 기원(Single origin)으로 향함
        </li>
        <li>
          단일 사용(Single use)
        </li>
        <li>
          한번도 사용되지 않았지만 짧은 수명의 단일 사용 전달자 토큰으로 교체됨
        </li>
      </ul>
    </section>

    <section class="informative" id="signature-based-correlation">
      <h3>서명 기반의 상관관계</h3>

      <p>
        <a>검증가능한 크리덴셜</a>의 내용은 <code>credential.proof</code> 필드를 사용하여 보호한다. 이 필드의
        <a>속성</a>들은 같은 값이 하나 이상의 세션 혹은 도메인에서 사용되고 그 값이 변하지 않을 경우
        더 큰 상관관계의 위험을 만들 수 있다. <code>verificationMethod</code>, <code>create</code>, <code>proofPurpose</code>,
        <code>jws</code> 필드가 이에 속한다.
      </p>

      <p>
        만약 강력한 상관관계 방지(Anti-Correlation) 속성이 필요할 경우, 제3자 쌍 서명,
        영지식증명 또는 집단 서명 등의 기술을 사용하여 매번 서명값과 메타데이터를 재생성하는
        것을 권장한다.

      </p>

      <p class="note">
        비록 상관관계 방지용 서명을 사용하더라도, <a>검증가능한 크리덴셜</a>에는 사용된 암호 기술의
        상관관계 방지 속성을 무력화시킬 수 있는 정보가 여전히 포함될 수 있다
      </p>
    </section>

    <section class="informative" id="long-lived-identifier-based-correlation">
      <h3>수명이 긴 식별자 기반의 상관관계</h3>

      <p>
        <a>Verifiable credentials</a> might contain long-lived identifiers that could
        be used to correlate individuals. These types of identifiers include
        <a>subject</a> identifiers, email addresses, government-issued identifiers,
        organization-issued identifiers, addresses, healthcare vitals,
        <a>verifiable credential</a>-specific JSON-LD contexts, and many other sorts of
        long-lived identifiers.
        <a>검증가능한 크리덴셜</a>은 개인의 상관관계를 파악하는데 사용될 수 있는 수명이 긴 식별자를
        포함할 수 있다. 이러한 종류의 식별자에는 <a>주체</a> 식별자, 이메일 주소, 정부 발행 식별자,
        조직 발행 식별자, 주소, 헬스케어 바이탈, <a>검증가능한 크리덴셜</a> 특화 JSON-LD 컨텍스트,
        그리고 수 많은 종류의 수명이 긴 식별자가 포함된다.
      </p>

      <p>
        <a>보유자</a>에게 소프트웨어를 제공하는 조직은 개인의 상관관계를 파악하는데 사용되는 정보가
        포함된 <a>검증가능한 크리덴셜</a>의 필드를 식별하여, 이 정보가 공유될 때 <a>보유자</a>에게 경고해야 한다
      </p>
    </section>

    <section class="informative" id="device-fingerprinting">
      <h3>디바이스 핑거프린팅</h3>

      <p>
        인터넷과 웹상에서 개인을 추적하고 상관관계를 파악하는데 사용되는 <a>검증가능한 크리덴셜</a>
        외부의 메커니즘들이 있다. 이러한 메커니즘은 인터넷 프로토콜(IP) 주소 추적,
        웹 브라우저 핑거프린팅, 에버쿠키(evercookie), 광고 네트워크 추적기,
        모바일 네트워크 위치 정보, 인앱 GPS API 등을 포함한다. <a>검증가능한 크리덴셜</a>을
        사용하는 것이 이러한 기술을 사용하는 것을 막지는 못한다. 또한, 이러한 기술들이
        <a>검증가능한 크리덴셜</a>과 결합되어 사용되면 새로운 상관관계를 파악할 수 있는
        정보들을 발견할 수도 있다. 예를 들어, 생일과 GPS 위치를 결합하면 다수의
        웹사이트에서 개인에 대한 강력한 상관관계를 파악하는데 사용될 수 있다.
      </p>

      <p>
        개인정보보호를 중요하게 여기는 시스템에서 <a>검증가능한 크리덴셜</a>을 사용하는 경우,
        이러한 추적 기술들의 사용을 방지하도록 하는 것이 권장한다. 경우에 따라서는 <a>보유자</a>를
        대신하여 <a>검증가능한 크리덴셜</a>을 전송하는 기기에서 추적 기술들이 비활성화 하는 것도 요구될 수 있다.
      </p>
    </section>

    <section class="informative" id="favor-abstract-claims">
      <h3>추상 클레임 선호(Flavor Abstract Claim</h3>

      <p>
        <a>검증가능한 크리덴셜</a>을 받는 사람이 필요 이상으로 개인식별정보를 노출하지 않으면서도
        다양한 상황에서 활용할 수 있도록 하기 위해 <a>발급자</a>는 <a>크리덴셜</a>의 정보를 예상되는 목적에
        필요한 최소한의 정보로 제한하는 것을 고려해야 한다. 개인식별정보를 <a>크리덴셜</a>에 포함하지
        않도록 하는 방법 중 하나는 <a>주체</a>에 대한 특정한 정보를 제공하지 않으면서도 <a>검증자</a>의
        요구를 만족시키는 추상 <a>속성</a>을 사용하는 것이다.
      </p>
      <p>
        예를 들면, 본 문서는 강력한 개인식별정보인 생일을 사용하는 대신 <code>ageOver</code> <a>속성</a>을 사용한다.
        만약 특정 시장의 소매업자가 일반적으로 구매자에게 특정 나이 이상을 요구하는 경우,
        그 시장에서 신뢰받는 <a>발급자</a>는 <a>주체</a>의 생일에 대한 <a>클레임</a>을 포함하는 <a>검증가능한 크리덴셜</a>을
        제공하기 보다는 <a>주체</a>가 그 조건을 만족한다고 주장하는 <a>검증가능한 크리덴셜</a>을 제공하는 것을
        선택할 것이다. 이로인해 개인 소비자가 특정 개인식별정보를 드러내지 않으면서도 구매를 할 수 있게 된다.
      </p>
    </section>

    <section class="informative" id="the-principle-of-data-minimization">
      <h3>데이터 최소화 원칙</h3>

      <p>
        한 컨텍스트에서 유출된 정보가 다른 컨텍스트로 유출되면 개인정보보호 위반이 발생한다.
        이러한 위반을 방지하기 위해 허용되는 모범 사례는 요청 및 수신한 정보를 최소한으로
        제한하는 것 이다. 데이터 최소화 접근법은 미국의
        HIPAA (Health Insurance Portability and Accountability Act) 및 EU의
        GDPR (General Data Protection Regulation)을 포함한 여러 관할권의 규정에 의해
        요구된다.
      </p>
      <p>
        <a>발급자</a>를 위한 데이터 최소화가 뜻하는 것은 <a>검증가능한 크리덴셜</a>의 사용을
        예상하여 잠재적 <a>검증자</a>가 요구하는 최소값으로 제한하는 것을 의미한다.
        <a>검증자</a>의 경우 데이터 최소화는 서비스 접근에 요구 또는 정보의 범위를 제한하는
        것을 의미한다.
      </p>
      <p>
        예를 들어, 면허 번호, 키, 몸무게, 생일, 주소가 포함된 운전 면허증은 개인이 특정 연령
        이상임을 확인하는데 필요한 것보다 많은 정보가 포함된 <a>크리덴셜</a>이다.
      </p>

      <p>
        <a>발급자</a>가 정보를 원자화하거나 <a>선택적 공개</a>를 허용하는 서명 체계를 사용하는
        것이 가장 좋은 사례이다. 예를 들어, 운전면허 <a>발급자</a>는 운전 면허에 나타나는
        모든 속성이 포함된 <a>검증가능한 크리덴셜</a>과 개인의 생일과 같은 단일 속성만
        포함되는 <a>검증가능한 크리덴셜</a> 집합을 발급할 수 있다. 또한, 더 추상적인
        <a>검증가능한 크리덴셜</a>을 발행할 수 있다 (예 : <code>ageOver</code> 특성만
        포함하는 <a>검증가능한 크리덴셜</a>). 한 가지 가능한 적용 방법은 <a>발급자</a>가
        <a>검증가능한 크리덴셜</a>의 익명 사용을 촉진하는 일회용 <a>무기명 크리덴셜</a>을
        검색하기 위한 보안 HTTP 엔드포인트를 제공하는 것이다. 부적절하거나 위험을 발견한
        구현자는 <a>선택적 공개</a>를 사용하여 <a>발급자</a>에 대한 의존성을 제거하고
        <a>발급자</a>의 일시적인 상관 위험을 줄여야 한다.
      </p>

      <p>
        <a>검증자</a>는 특정 트랜젝션이 발생하는데 꼭 필요한 정보만 요청해야 한다.
        이는 두 종류의 이유로 중요하다:
      </p>

      <ul>
        <li>
          불필요한 매우 민감한 정보를 처리하는 <a>검증자</a>의 책임을 줄임
        </li>
        <li>
          특정 트랜젝션에 필요한 정보만 요구함으로써 개인의 프라이버시를 향상
        </li>
      </ul>

      <p class="note">
        최소 공개 원칙을 실행하는 것은 가능하지만, 단일 또는 다중 세션 동안 특정 사례에서
        개인의 강력한 식별을 피하는 것은 불가능할 수 있다. 본 표준의 저자는 실제 시나리오에서
        원칙을 달성하는 것은 어려울 수 있다고 강요하지 않는다.
      </p>
    </section>

    <section class="informative" id="bearer-credentials">
      <h3>무기명 크리덴셜</h3>

      <p>
        <dfn data-lt="bearer credentials">무기명 크리덴셜</dfn>은 콘서트 티켓과 같은
        개인정보보호 강화 정보로, <a>보유자</a>에게는 자신에 대한 민감한 정보를 공개하지
        않고도 특정 자원에 대한 크리덴셜을 부여 할 수 있다. 무기명 크리덴셜은 종종
        무기명 크리덴셜 공유가 문제가 되지 않거나 경제적 또는 평판의 손실이 크지 않은
        저 위험 사례에서 사용된다.
      </p>

      <p>
        <a>무기명 크리덴셜</a>인 <a>검증가능한 크리덴셜</a>은
        <code>credentialSubject</code> <a>속성</a>에 중첩된 <code>id</code> <a>속성</a>을
        사용하여 표현된 <a>주체</a> 식별자를 지정하지 않으면 가능하다.
        예를 들어 다음과 같은 <a>검증가능한 크리덴셜</a>은 <a>무기명 크리덴셜</a>이다:
      </p>

      <pre class="example nohighlight" title="발급자 속성 사용">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/temporary/28934792387492384",
  "type": ["VerifiableCredential", "UniversityDegreeCredential"],
  "issuer": "https://example.edu/issuers/14",
  "issuanceDate": "2017-10-22T12:23:48Z",
  "credentialSubject": {
    <span class="comment">// 무기명 크리덴셜에 ‘id’ 속성이 지정되어 있지 않음</span>
    "degree": {
      "type": "BachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  "proof": { <span class="comment">...</span> }
}
      </pre>

      <p>
        <a>무기명 크리덴셜</a>은 개인정보보호를 강화할 수 있지만, <a>무기명 크리덴셜</a>
        <a>보유자</a>가 예상한 것보다 더 많은 정보를 실수로 공개하지 않도록 신중하게 만들어야
        한다. 예를 들어, 다수의 사이트에서 동일한 <a>무기명 크리덴셜</a>을 반복적으로 사용하면
        사이트들이 담합하여 잠재적으로 <a>보유자</a>를 추적하거나 연동시킬 수 있다.
        또한 생년월일 및 우편 번호와 같이 식별할 수 없는 것처럼 보이는 정보를 사용하여 동일한
        <a>무기명 크리덴셜</a> 또는 세션에서 함께 사용될 경우, 개인을 통계적으로 식별할 수 있다.
      </p>

      <p>
        <a>무기명 크리덴셜</a> <a>발급자</a>는 <a>무기명 크리덴셜</a>이 다음과 같은
        개인정보보호 강화를 제공하는지 확인해야 한다:
      </p>

      <ul>
        <li>
          가능하면 일회용
        </li>
        <li>
          개인 식별정보를 포함하지 않음
        </li>
        <li>
          과도하게 상관되지 않음
        </li>
      </ul>

      <p>
        민감한 정보가 포함된 <a>무기명 크리덴셜</a>이 발행, 요청되거나 하나 이상의 세션에서
        두 가지 이상의 <a>무기명 크리덴셜</a>을 결합되거나 상관 관계 위험이 있는 경우,
        소프트웨어는 <a>보유자</a>에게 경고해야 한다. 모든 상관 관계 위험을 감지하는 것은
        불가능하지만 일부는 확실하게 감지할 수 있다.
      </p>

      <p>
        <a>검증자</a>는 <a>보유자</a>와의 상관 관계를 파악하는데 사용할 수 있는 <a>무기명 크리덴셜</a>을 요청하지 말아야 한다.
      </p>
    </section>

    <section class="informative" id="validity-checks">
      <h3>유효성 검사</h3>

      <p>
        <a>검증가능한 크리덴셜</a>을 처리할 때 <a>검증자</a>는 <a href="#validation"></a>의
        유효성 검증 및 다양한 특정 비즈니스 프로세스 점검에 나열된 검사를 수행해야 한다.
        유효성 검사는 아래 항목이 포함된다:
      </p>

      <ul>
        <li>
          <a>보유자</a>의 전문 라이센스 상태.
        </li>
        <li>
          라이센스 갱신 또는 폐기 날짜.
        </li>
        <li>
          개인의 하위 자격.
        </li>
        <li>
          <a>보유자</a>와 상호 작용을 시도하는 <a>개체</a>와 관계가 있는 경우.
        </li>
        <li>
          <a>보유자</a>와 관련된 지리적 위치 정보.
        </li>
      </ul>

      <p>
        이러한 검사를 수행하면 정보 유출로 인해 <a>보유자</a>의 개인정보보호 위반이
        발생할 수 있다. 예를 들어 폐기 목록 확인과 같은 간단한 조작으로 특정 비즈니스가
        <a>보유자</a>와 상호작용 한다는 것을 <a>발급자</a>에게 알릴 수 있다.
        이는 <a>발급자</a>들은 담합과 연동을 개인들에 대한 정보 없이 할 수 있다.
      </p>

      <p>
        <a>발급자</a>는 <a>크리덴셜</a>마다 <a>검증</a>과정에서 개인정보보호 위반이 발생할
        수 있는 구간에 <a>크리덴셜</a>마다 고유한 폐기 목록과 같은 메커니즘을 사용하지
        않아야 한다. <a>보유자</a>에게 소프트웨어를 제공하는 조직은 <a>크리덴셜</a> 검증 과정
        중에 개인정보보호 위반으로 이어질 수 있는 정보가 포함된 경우 경고해야 한다.
        <a>검증자</a>는 개인정보 침해를 유발하거나 개인정보보호 정책을 위반하는
        <a>크리덴셜</a>을 거부해야 한다.
      </p>
    </section>

    <section class="informative" id="storage-providers-and-data-mining">
      <h3>저장소 제공자와 데이터 마이닝</h3>

      <p>
        <a>보유자</a>가 <a>발급자</a>로부터 <a>검증가능한 크리덴셜</a>을 받으면 <a>검증가능한 크리덴셜</a>은 어딘가에 저장되어야 한다 (예: <a>크리덴셜</a> 저장소). 
        <a>보유자</a>는 <a>검증가능한 크리덴셜</a>의 정보가 본질적으로 민감하고, 고도로 개인화되어 데이터 마이닝의 가치 높은 대상이 된다는것을 경고받는다. 
        <a>검증가능한 크리덴셜</a>의 무료 저장을 홍보하는 서비스는 실제로 개인 데이터를 마이닝하여 개인 및 조직에 대한 개인화된 프로필을 구축하려는 조직에 판매하는 것일 수 있다.
      </p>
      <p>
        <a>보유자</a>들은 <a>크리덴셜</a> 저장소의 서비스 약관, 특히 서비스 제공 업체에 <a>검증가능한 크리덴셜</a>을 저장하는 사람들을 위한 
        상관 관계 및 데이터 마이닝으로부터 보호에 대한 부분을 알고있어야 한다.
      </p>
      <p>
        데이터 마이닝 및 프로파일링에 대한 몇가지 효과적인 방법은 다음과 같다:
      </p>

      <ul>
        <li>
          사용자의 정보를 제 3자에게 판매하지 않는 서비스 제공자.
        </li>
        <li>
          서비스 제공 업체가 <a>크리덴셜</a>의 내용을 볼 수 없도록 <a>검증가능한 크리덴셜</a>을 암호화하는 소프트웨어.
        </li>
        <li>
          <a>검증가능한 크리덴셜</a>을 사용자가 제어하는 장치에 로컬로 저장하고 예상보다 많은 정보를 업로드하거나 분석하지 않는 소프트웨어
        </li>
      </ul>
    </section>

    <section class="informative" id="aggregation-of-credentials">
      <h3>크리덴셜의 수집</h3>

      <p>
        동일한 <a>주체</a>에 대해 두 개의 정보를 보유하면, 그 정보가 다른 채널을 통해 전달되는 경우에도 그 <a>주체</a>에 대해 두 개의 합계보다 더 많은 정보를 노출하게 된다. 
        <a>검증가능한 크리덴셜</a>을 수집하는것은 프라이버시 위험이며 이 생태계의 모든 참가자들은 데이터 수집의 위험성을 알고있어야 한다.
      </p>

      <p>
        예를 들어, 이메일 주소에 대한 <a>크리덴셜</a>이 하나 있고 <a>보유자</a>가 21세 이상이라는 사실에 대한 크리덴셜이 하나 있는 상황에서 두개의 
        크리덴셜이 다수의 세션에 걸쳐 공유되었다면, <a>검증자</a>는 이제 그 개인에 대한 고유한 식별자와 연령 관련 정보를 갖게 된다. 
        이제 시간이 갈수록 그 <a>보유자</a>에 대한 프로필을 생성하기 점점 더 쉬워진다. 여러 사이트에서 <a>크리덴셜</a> 수집을 할수도 있고, 
        이는 심각한 프라이버시 문제를 초래할 수도 있다.
      </p>

      <p>
        기술적인 관점에서 볼 때 정보 수집을 방지하는것은 매우 어려운 프라이버시 문제이다. 
        영지식증명과 같은 새로운 암호화 기술이 수집 및 상관관계 문제에 대한 솔루션으로 제안되고 있지만, 
        오래 지속되는 식별자와 브라우저 추적 기술의 존재는 가장 현대적인 암호화 기술조차도 능가한다.
      </p>

      <p>
        상관관계 또는 수집의 프라이버시 영향에 대한 해결책은 본질적으로 기술적인것이 아니라 정책 중심이다. 
        따라서 <a>보유자</a>가 자신에 대한 정보가 수집되길 바라지않는 경우, 그들이 보내는 <a>검증가능한 프레젠테이션</a>에 표시해야 한다.
      </p>
    </section>

    <section class="informative" id="usage-patterns">
      <h3>사용 패턴들</h3>

      <p>
        개인정보보호를 위한 최선의 노력에도 불구하고 실제로 <a>검증가능한 크리덴셜</a>을 사용하면 익명성이 해제되고 프라이버시가 손실될 수 있다. 
        이 상관관계는 다음과 같은 경우에 발생할 수 있다:
      </p>

      <ul>
        <li>
          동일한 <a>검증가능한 크리덴셜</a>이 동일한 <a>검증자</a>에게 두 번 이상 제공되었을 경우. <a>검증자</a>는 <a>보유자</a>가 동일한 인물임을 유추할 수 있다.
        </li>
        <li>
          동일한 <a>검증가능한 크리덴셜</a>이 다른 <a>검증자들</a>에게 제공되며, 해당 <a>검증자들</a>들이 공모하거나 제 3자가 두 <a>검증자</a> 모두의 거래기록에 접근가능할 경우. 
          관찰자는 두 서비스에서 <a>검증가능한 크리덴셜</a>을 제출한 사람이 동일한 사람임을 유추할 수 있다. 즉, 계정들은 같은 사람에 의해 제어되고 있다는 사실을 알 수 있다.
        </li>
        <li>
          <a>크리덴셜</a>의 <a>주체</a> 식별자가 여러 <a>프레젠테이션들</a> 또는 <a>검증자들</a>에게 동일한 경우. 
          서로 다른 <a>크리덴셜</a>이 제출되었어도 <a>주체</a> 식별자가 같다면 <a>검증자들</a>(그리고 검증 기록을 조회할 수 있는 사람들)은 <a>크리덴셜</a>의 <a>보유자</a>가 동일인물임을 유추할 수 있다.
        </li>
        <li>
          <a>크리덴셜</a>의 기본 정보는 서비스들 전체에서 개인을 식별하는데 사용될 수 있다. 이 경우, 
          <a>검증자들</a>은 다른 출처의 정보(<a>보유자</a>가 직접 제공한 정보 포함)를 사용하여 <a>크리덴셜</a>의 내용으로 개인을 기존 프로필과 연관시킬 수 있다. 
          예를 들어, <a>보유자</a>가 우편번호, 나이, 성별을 포함한 <a>크리덴셜</a>을 제시하면 <a>검증자</a>가 해당 <a>크리덴셜</a>의 <a>주체</a>를 설정된 프로필과 연관시킬 수 있다. 
          자세한 내용은 [[DEMOGRAPHICS]]를 참조.
        </li>
        <li>
          <a>크리덴셜</a>의 식별자를 중앙화된 폐기 서버에 전달할 경우. 중앙 서버는 상호 작용에서 <a>크리덴셜</a>을 연관시킬 수 있다. 
          예를 들어 <a>크리덴셜</a>이 이러한 방식으로 나이를 증명하는데 사용되는 경우 중앙 서비스는 <a>크리덴셜</a>이 제공된 모든곳 
          (모든 주류 상점, 술집, 성인 상점, 복권 구매 등)을 알 수 있다. 
        </li>
      </ul>

      <p>
        어떤 부분들은 다음과 같은 방법으로 비익명화 및 프라이버시 손실을 완화 할 수 있다:
      </p>

      <ul>
        <li>
          <a>크리덴셜</a>의 <a>주체</a>로 전역 고유 식별자를 사용하고 해당 <a>크리덴셜</a>을 재사용 하지 않을것.
        </li>
        <li>
          <a>크리덴셜</a>이 폐기를 지원하는 경우 전세계에 분산된 서비스를 사용하여 폐기할것.
        </li>
        <li>
          <a>크리덴셜</a>의 ID 제출에 의존하지 않는 크리덴셜 폐기 API 설계. 예를 들어, 쿼리 대신 폐기 목록을 사용할 것.
        </li>
        <li>
          개인 식별 정보와 특정 장수식별자와의 연관성을 피할것
        </li>
      </ul>

      <p>
        이러한 완화 기술이 항상 실용적이거나 필요한 사용법과 호환되는 것은 아님을 이해해야 한다. 때로는 상관관계가 필요하기도 하다.
      </p>
      <p>
        예를 들어, 일부 처방약 모니터링 프로그램에서는 사용량 모니터링이 필요하다. 
        집행 주체는 개인이 통제 약품에 대해 복수의 처방을 받기 위해 시스템을 속이는 것이 아님을 확인할 수 있어야 한다. 
        사용량의 상관관계를 위한 법규나 규정은 개인의 프라이버시 문제보다 중요하다.
      </p>

      <p>
        <a>검증가능한 크리덴셜</a>은 서비스들 사이에서 의도적으로 연관시키는 경우가 있다. 
        예를 들어, 동일 페르소나가 다수의 서비스에 로그인 할 때, 각각의 서비스에서 활동들이 의도적으로 동일 인물에게 연결된다. 
        이러한 각 서비스들이 예상한 방식으로 상관관계를 사용하는 한 프라이버시 문제는 아니다.
      </p>

      <p>
        <a>크리덴셜</a>을 사용하여 의도하지 않거나 예기치 않은 상관관계가 발생하면 <a>크리덴셜</a>의 프라이버시 위험이 발생한다.
      </p>
    </section>

    <section class="informative" id="sharing-information-with-the-wrong-party">
      <h3>잘못된 당사자에게 정보 공유</h3>

      <p>
        어떤 <a>보유자</a>가 어떤 <a>검증자</a>와 정보를 공유하기로 결정했을 때,
        그 <a>검증자</a>는 정직하지 못하게 행동하면서 <a>보유자</a>에게 해를 끼치는데 사용할 수 있는 정보를 요청하는 경우가 발생할 수 있다.
        예를 들어, <a>검증자</a>는 은행 계좌 번호를 요청하고 다른 정보와 함께 사용함으로써 <a>보유자</a>나 은행을 속일 수 있다.
      </p>

      <p>
        <a>발급자</a>는 가능한 많은 정보를 토큰화함으로써,
        <a>보유자</a>가 뜻하지 않게 <a>크리덴셜</a>들을 잘못된 <a>검증자</a>에게 전달한 경우에도,
        그 상황이 재앙이 되지 않도록 노력해야 한다.
      </p>

      <p>
        예를 들어 개인의 은행 잔고를 확인하기 위해 은행 계좌 번호를 (<a>검증가능한 크리덴셜</a>에) 포함하는 대신에,
        잔액이 얼마 이상인지만 <a>검증자</a>가 확인하는데 사용할 수 있는 토큰을 제공할 수 있다.
        이 경우에 은행은 잔액 확인용 토큰이 포함된 <a>검증가능 크리덴셜</a>을 <a>보유자</a>에게 발급할 수 있다.
        <a>보유자</a>는 그 <a>검증가능한 크리덴셜</a>을 <a>검증가능한 프레젠테이션</a>에 포함하고,
        전자 서명을 이용하여 그 토큰을 신용 조회 기관에 결합시킨다.
        <a>검증자</a>는 그들의 전자서명으로 <a>검증가능한 프레젠테이션</a>을 한번 감싸고,
        그것을 <a>발급자</a>에게 돌려주므로써 동적으로 계좌 잔액을 확인할 수 있다.
      </p>

      <p>
        이러한 접근 방식을 이용하여, <a>보유자</a>가 계좌 잔액 토큰을 잘못된 당사자에게 공유했다 하더라도
        공격자는 은행 계좌 번호나 정확한 계좌 잔고를 알 수 없게 된다.
        그리고 (보유자의) 카운터 서명에 주어진 유효 기간으로 인해, 몇 분이 지나면 토큰에 대한 접근 권한을 얻지 못하게 된다.
      </p>
    </section>

    <section class="informative" id="frequency-of-claim-issuance">
      <h3>클레임 발급 빈도</h3>

      <p>
        섹션 <a href="#usage-patterns"></a>에 자세히 설명한 것처럼, 사용 패턴은 특정 형태의 행위와 연관될 수 있다.
        이러한 연관성은 <a>보유자</a>가 <a>발급자</a>에 대한 지식 없이 <a>검증가능한 크리덴셜</a>을 사용함으로써 일부 완화된다.
        그러나 <a>발급자</a>는 그들이 발급하는 <a>검증가능한 크리덴셜</a>을 단기적이고 자동갱신 되도록 만듬으로써 이러한 보호를 의미없게 만들 수 있다.
      </p>

      <p>
        예를 들어, <code>ageOver</code> <a>검증가능 크리덴셜</a>은 술집 출입 가능 여부를 판단하는데 유용하다.
        만약 <a>발급자</a>가 그러한 <a>검증가능 크리덴셜</a>을 아주 짧은 만료 시기와 자동 갱신 메커니즘으로 발급한다면,
        <a>발급자</a>는 <a>보유자</a>의 행위를 <a>보유자</a>에게 부정적인 영향을 미치는 방식으로 연관시킬 수 있다.
      </p>

      <p>
        <a>보유자</a>에게 소프트웨어를 제공하는 조직들은 <a>보유자</a>가 짧은 수명을 가진 <a>크리덴셜</a>을 반복적으로 사용하는 경우에
        <a>보유자</a>에게 행위 연관성이 발생할 수 있음을 경고해야 한다.
        <a>발급자</a>는 사용 패턴을 연관시키는 방식의 <a>크리덴셜</a> 발급을 피해야한다.
      </p>
    </section>

    <section class="informative" id="prefer-single-use-credentials">
      <h3>일회용 크리덴셜 선호</h3>

      <p>
        이상적인 사생활 존중 시스템은 <a>검증자</a>와 상호작용하기 위해 필요한 정보만을 <a>보유자</a>가 공개하도록 요구한다.
        <a>검증자</a>는 공개 요구사항을 만족하는 정보만을 기록하고, 공개된 정보 중 나머지 민감한 정보는 저장하지 않는다.
        많은 경우에 규제적인 부담과 같은 우선순위의 경쟁으로 인해 이런 이상적인 시스템을 채택하는 것이 쉽지 않다.
        다른 경우는, 수명이 긴 식별자가 일회성을 저해한다.
        그러나 모든 <a>검증가능한 크리덴셜</a> 생태계의 설계는 가능할 때마다 일회용 <a>검증가능한 크리덴셜</a>을 선호함으로써 사생활을 존중하기 위해 노력해야 한다.
      </p>

      <p>
        일회용 <a>검증가능한 크리덴셜</a>을 사용하는 것은 여러가지 이점이 있다.
        첫번째 이점은 <a>검증자</a> 입장에서 <a>검증가능한 크리덴셜</a>에 있는 데이터가 최신이라는 것을 확신할 수 있다는 점이다.
        두번째 이점은 <a>보유자</a> 입장에서 만약 수명이 긴 식별자가 <a>검증가능한 크리덴셜</a>에 존재하지 않는다면
        <a>검증가능한 크리덴셜</a> 자체는 온라인 상에서 자신을 추적하거나 연관시킬 수 없다는 점을 알게된다는 점이다.
        마지막으로 공격자가 훔칠만한 것이 존재하지 않기 때문에 운영되는 전체 생태계가 더 안전해진다는 것이다.
      </p>
    </section>

    <section class="informative" id="private-browsing">
      <h3>시크릿 브라우징 모드</h3>

      <p>
        이상적인 시크릿 브라우징 모드 시나리오에서는,
        어떤 개인 개인식별정보(PII, Personally Identifiable Information)도 노출되지 않을 것이다.
        많은 <a>크리덴셜</a>들이 개인식별정보를 포함하고 있기 때문에,
        소프트웨어를 제공하는 조직들은 시크릿 브라우징 모드에서 <a>크리덴셜</a>과 <a>프레젠테이션</a>을 사용하면
        개인식별정보가 노출될 수 있음을 <a>보유자</a>에게 경고해야 한다.
        각 브라우저 공급자들마다 시크릿 모드를 처리하는 방식이 다르고,
        어떤 브라우저는 이러한 경고 기능을 제공하지 않을 수도 있기 때문에,
        구현자들이 이러한 차이점을 인지하고 그에 맞게 솔루션을 구현하는 것이 중요하다.
      </p>
    </section>


  </section>

  <section class="informative" id="security-considerations">
    <h2>보안 고려사항</h2>

    <p>
      <a>발급자</a>, <a>보유자</a>, <a>검증자</a>가 이 명세서에서 설명하고 있는 데이터를 처리할 때 인지하고 있어야 하는 보안 고려사항이 아주 많이 있다.
      이 섹션에서 설명하는 내용이 함축하는 바를 무시하거나 이해하지 못한다면 보안 취약점이 발생할 수 있다.
    </p>

    <p>
      이번 섹션에서 다양한 보안 고려사항을 강조하고 있지만, 이것이 완전한 리스트는 아니다.
      구현자는 이 명세서에서 서술한 기술을 이용하여 미션 크리티컬한 시스템을 구축하는 경우,
      보안과 암호학 전문가들에게 추가적인 조언을 구해야 한다.
    </p>

    <section class="informative" id="cryptography-suites-and-libraries">
      <h3>암호화 스위트와 라이브러리</h3>

      <p>
        이 명세서에서 설명한 데이터 모델의 일부 측면은 암호학을 이용하여 보호할 수 있다.
        구현자가 <a>크리덴셜</a>과 <a>프레젠테이션</a>을 생성하고 처리함에 있어서 사용되는 암호화 스위트와 라이브러리를 이해하는 것은 중요하다.
        암호화 시스템을 구축하고 감사하는 것은 일반적으로 상당한 경험을 필요로 한다.
        효과적인 <a href="https://en.wikipedia.org/wiki/Red_team">레드팀 구성</a>을 통해 보안성 리뷰에서 나타날 수 있는 편향을 방지할 수 있다.
      </p>

      <p>
        암호화 스위트와 라이브러리는 일종의 유통기한이 있어서 결국 새로운 공격과 기술 발달에 노출된다.
        제품 품질 관리 시스템은 이러한 특성을 고려하여 만료되거나 깨진 암호화 수트와 라이브러리를
        간단히 선제적으로 업그레이드가 가능하도록 구성하고,
        이미 발급된 <a>크리덴셜</a>을 무효화하고 교체할 수 있는 메커니즘을 보장해야 한다.
        주기적인 모니터링은 <a>크리덴셜</a>을 처리하는 시스템의 장기 생존을 보장하는데 중요하다.
      </p>
    </section>

    <section id="content-integrity-protection" class="informative">
      <h3>내용 무결성 보호</h3>

      <p>
        <a>검증가능한 크리덴셜</a>에는 외부에서 자신을 검증하기 위한 <a>검증가능한 크리덴셜</a>을 가르키는 URL들이 종종 포함되어 있다. 외부에 존재하는 이미지, JSON-LD 컨택스트 및
        기계판독가능데이터들과 같은 링크된 컨텐츠는 <a>검증가능한 크리덴셜</a>의 <a href="#proofs-signatures">증명</a>을 통한 보호에서 벗어나 있기 때문에, 변조로 부터 종종
        보호되지 않는다. 예를 들어 다음과 같이 강조표시된 링크들은 컨탠츠 무결성이 보호되지 않지만, 아마도 다음과 같을 것이다.
      </p>

      <pre class="example nohighlight" title="Non-content-integrity protected links">
{
  "@context": [
    <span class="highlight">"https://www.w3.org/2018/credentials/v1"</span>,
    <span class="highlight">"https://www.w3.org/2018/credentials/examples/v1"</span>
  ],
  "id": "http://example.edu/credentials/58473",
  "type": ["VerifiableCredential", "AlumniCredential"],
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "image": <span class="highlight">"https://example.edu/images/58473"</span>,
    "alumniOf": {
      "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
      "name": [{
        "value": "Example University",
        "lang": "en"
      }, {
        "value": "Exemple d'Université",
        "lang": "fr"
      }]
    }
  },
  "proof": { <span class="comment">...</span> }
}
      </pre>

      <p>
        이 규격에서 내용 무결성 보호를 위해 특정한 방법을 권장하지 않지만, 링크된 내용의 무결성 보호를 원하는 작성자는 내용의 무결성을 강화하는 URL체계를 사용할 것을 권장한다. 이러한 2가치 체계는
        [[HASHLINK]]규격과 [[IPFS]]이다. 다음의 예제는 이전의 예를 변형해서 [[HASHLINK]]규격을 이용해 JSON-LD 컨텍스트에 내용 무결성 보호를 추가하고, [[IPFS]] 링크를
        사용하여 이미지에 내용 무결성 보호를 추가하였다.
      </p>

      <pre class="example nohighlight" title="Content-integrity protection for links to external data">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1<span class="highlight">?hl=z3aq31uzgnZBuWNzUB</span>",
    "https://www.w3.org/2018/credentials/examples/v1<span class="highlight">?hl=z8guWNzUBnZBu3aq31</span>"
  ],
  "id": "http://example.edu/credentials/58473",
  "type": ["VerifiableCredential", "AlumniCredential"],
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "image": <span class="highlight">"ipfs:/ipfs/QmXfrS3pHerg44zzK6QKQj6JDk8H6cMtQS7pdXbohwNQfK/image"</span>,
    "alumniOf": {
      "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
      "name": [{
        "value": "Example University",
        "lang": "en"
      }, {
        "value": "Exemple d'Université",
        "lang": "fr"
      }]
    }
  },
  "proof": { <span class="comment">...</span> }
}
      </pre>

      <p class="note">
        프로덕션 구현에는 중요한 JSON-LD 컨텍스트의 정적 사본이 제공 될 것으로 예상되므로, 위의 JSON-LD 컨텍스트에 보호가 필요한지 여부는 논란의 여지가 있다.
      </p>

      <p>
        위의 예는 내용 무결성 보호를 달성하는 한 가지 방법이지만 특정 애플리케이션들에 더 적합한 다른 솔루션들이 있다. 구현자들은 내용 무결성으로 보호되지 않는 외부의 기계판독가능한 내용들에 대한
        링크가 어떻게 그들의 어플리케이션에 대한 성공적인 공격을 만들어 낼 수 있는지 이해해야 한다.
      </p>

    </section>

    <section id="unsigned-claims" class="informative">
      <h3>서명되지않은 클레임</h3>

      <p>
        이 규격은 어떠한 서명이나 증명도 포함하지 않은 <a>크리덴셜</a>을 만들 수 있도록 한다. 이러한 유형의 <a>크리덴셜</a>은 웹 페이지에서 양식을 작성하는 것과 유사한 자가증명, 중간 저장소에
        종종 유용하다. 구현자는 이러한 종류의 <a>크리덴셜</a>들은 작성자가 알려지 있지 않거나, 신뢰할 수 없기 떄문에 <a>검증</a>할 수 없다는걸 알아야 한다.
      </p>
    </section>

    <section id="token-binding" class="informative">
      <h3>토큰 바인딩</h3>

      <p>
        <a>검증자</a>는 이것이 <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">중간자 공격</a>의 목표가 아닌 <a>검증가능한
          프레젠테이션</a>의 수신자인지 확인해야 할 수도 있다. 요청에 의해서 <a>검증가능한 프레젠테이션</a> 응답을 묶은 토큰 바인딩 [[RFC8471]]과 같은 접근 방법으로 프로토콜을 보호할 수
        있다. 보안되지 않은 모든 프로토콜은 중간자 공격에 취약하다.
      </p>
    </section>

    <section id="bundling-dependent-claims" class="informative">
      <h3>의존하는 클레임들 번들링</h3>

      <p>
        <a>발급자</a>가 <a>크리덴셜</a>의 정보를 원자화하거나, 선택적 공개를 허용하는 서명체계를 이용하는 것이 가장 좋다. 원자화의 경우에, 만약 <a>발급자</a>에 의해 안전하게 완료되지
        않았다면, <a>발급자</a>가 의도하지 않은 방식으로 <a>보유자</a>의 다른 <a>크리덴셜</a>과 묶일 수 있다.
      </p>

      <p>
        예를 들어, 대학은 한사람에게 2종류의 <a>검증가능한 크리덴셜</a>을 발급할 수 있는데, 각 자격증에는 "컴퓨터 부서"의 "담당자" 또는 "경제학과"의 "대학원생"과 같이 주어진 "부서"와
        "역할"의 2가지 <a>속성</a>이 각각 포함되어 있다. 만약 이러한 속성들 중 단지 하나만이 <a>크리덴셜</a>에 포함되어 원자화된다면, 대학은 한사람에게 4개의 <a>크리덴셜</a>을
        발급해야 한다. 각각의 <a>크리덴셜</a>들은 "직원", "대학원생", "컴퓨터 부서", "경제학과"가 될 것이다. <a>보유자</a>는 <a>검증자</a>에게 "직원"과 "경제학과"의
        <a>검증가능한 크리덴셜</a>을 전송할 수 있으며, 이는 잘못된 <a>클레임</a>이 된다.
      </p>
    </section>

    <section id="highly-dynamic-information" class="informative">
      <h3>매우 동적인 정보</h3>

      <p>
        매우 동적인 정보에 대한 <a>검증가능한 크리덴셜</a>을 발급하는 경우, 구현자는 만료기간을 적절하게 설정해야한다. <a>검증가능한 크리덴셜</a>의 유효기간보다 만료기간이 더 길다면 악용가능한
        보안취약성이 발생할 수 있다. <a>검증가능한 크리덴셜</a>을 통해 표현되는 정보의 만료기간이 유효기간보다 짧으면 <a>보유자</a>와 <a>검증자</a>에게 부담을 준다. 따라서 사용사례와
        <a>검증가능한 크리덴셜</a>에 포함된 정보의 예상 수명에 유효기간의 적절한 설정은 중요하다.
      </p>
    </section>

    <section class="informative" id="device-theft-and-impersonation">
      <h3>장치 분실 및 도용</h3>

      <p>
        <a>검증가능한 크리덴셜</a>이 저장된 장치가 분실되거나 도난당했을 때, 공갹자가 피해자의 <a>검증가능한 크리덴셜</a>을 사용하여 시스템에 접속할 수 있다. 
        이러한 유형의 공격을 완화하는 방법으로는:
      </p>

      <ul>
        <li>
          장치에서 암호, 핀, 패턴 또는 생체인식 화면잠금 보호 활성화.
        </li>
        <li>
          <a>크리덴셜</a> <a>저장소</a>에 암호, 생체 인식 또는 다중 인증 활성화.
        </li>
        <li>
          암호 키에 액세스할 때 암호, 생체인식 또는 다중 인증 활성화.
        </li>
        <li>
          별도의 하드웨어 기반 서명 장치 사용.
        </li>
        <li>
          상기의 전부 또는 임의의 조합.
        </li>
      </ul>
    </section>
  </section>

  <section id="accessibility-considerations" class="informative">
    <h2>접근성 고려</h2>

    <p>
      구현자가 이 규격에 기술된 데이터를 처리할 때 알아야할 많은 접근성에 대한 고려사항이 있다. 모든 웹표준 또는 프로토콜의 구현과 마찬가지로 접근성 문제에 대한 무시하게 되면 모집단의 상당부분에서 이 정보를
      이용할수 없게 된다. [[WCAG21]]과 같은 접근성 가이드라인과 표준을 지켜 모든 사람들이 능력에 개의치 않고 이 정보를 사용할 수 있게 만드는 것은 매우 중요하다. 역사적으로 보조기술에 문제를 야기한
      암호학을 이용한 시스템을 구축할 때 이것은 특별히 중요하다.
    </p>

    <p>
      이 절에서는 이 데이터 모델을 활용할 때 고려해야 할 일반적인 접근성에 대한 고려사항을 자세히 설명한다.
    </p>

    <section id="data-first-approaches" class="informative">
      <h3>데이터 우선 접근</h3>

      <p>
        정부에서 발행한 신분증과 같이 오늘날 사용하고 있는 많은 물리적인 <a>인증서</a>들은 인쇄가 너무 작거나, 작지만 고해상도의 이미지에 의존하거나, 시각적 장애를 가진 사람들에게 제공할 수 없는 등의
        제약이 포함되어 있는 특징들에 의해 접근성이 매우 열악하다.
      </p>

      <p>
        데이터모델을 이용해 <a>검증가능한 크리덴셜</a>을 만들때, 데이터 모델 디자이너는 <em>데이터 우선 접근</em> 방식을 사용하는 것이 좋다. 예를 들어, <a>크리덴셜</a>을 묘사하기 위해
        데이터 또는 그래픽 이미지를 사용하기로 선택한 경우, 디자이너는 기관의 이름 또는 전문 자격과 같은 이미지의 모든 요소를 시청자의 해석에 의존하지 말고 기계판독이 가능한 방식으로 표현해야한다. 데이터
        우선 접근 방식은 다양한 능력을 가진 사람들을 위해 서로 다른 인터페이스를 구축을 위한 기본 요소를 제공하기 때문에 선호된다.
      </p>
    </section>
  </section>

  <section class="informative" id="internationalization-considerations">
    <h2>국제화 고려 사항</h2>

    <p>
      구현자는 이 사양에 설명 된 데이터를 게시 할 때 여러 국제화 고려 사항을 알고 있어야 한다.
      웹 표준 또는 프로토콜 구현과 마찬가지로 국제화를 무시하면
      데이터의 다른 언어와 사회에서 데이터를 생성하고 소비하기가 어려워지므로
      사양의 적용 가능성이 제한되고 표준으로서의 가치가 크게 떨어진다.
    </p>

    <p>
      구현자는 국제화를 지원하기 위해 텍스트에 대한 신뢰할 수 있는 메타 데이터를 제공하는
      W3C 국제화 활동에서 발행 한
      <em>웹에서 문자열 : 언어 및 방향 메타 데이터</em> 문서 [[STRING-META]] 읽기를 권장한다.
      국제화 고려 사항에 대한 최신 정보를 얻으려면
      구현자는 확인 가능한 자격 증명 구현 지침 [[VC-IMP-GUIDE]] 문서를 읽어야한다.
    </p>

    <p>
      이 섹션에서는이 데이터 모델을 사용할 때 고려해야 할 일반적인 국제화 고려 사항에 대해 간략하게 설명하고 있으며
      구현자가 관심 있을 <em>웹에서 문자열 : 언어 및 방향 메타 데이터</em> 문서 [[STRING-META]]의
      특정 부분을 강조하기 위해 구현되었다.
    </p>

    <section class="informative" id="language-and-base-direction">
      <h3>언어와 기본 방향</h3>

      <p>
        데이터 퍼블리셔는 <em>웹에서 문자열 : 언어 및 방향 메타 데이터</em> 문서 [[STRING-META]]의
        교차 구문 표현식 섹션을 읽고 [[JSON-LD]], [[JSON]] 및 CBOR [[?RFC7049]]와 같이 여러 표현식 구문에서
        언어 및 기본 방향 정보를 표현할 수 있도록 하는 것이 좋다.
      </p>

      <p>
        일반적인 디자인 패턴은 언어 및 선택적으로 특정 기준 방향으로
        태그가 지정된 텍스트 문자열을 표현할 때 다음 마크 업 템플릿을 사용하는 것이다.
      </p>

      <pre class="example nohighlight" title="자연어 문자열의 디자인 패턴">
"<a>property</a>": {
  "value": "<span class="highlight">The string value</span>",
  "lang": "<code>LANGUAGE</code>"
  "dir": "<code>DIRECTION</code>"
}
      </pre>

      <p>
        위의 디자인 패턴을 사용하여 다음 예제는 텍스트 방향을 지정하지 않고 책 제목을 영어로 표현한다.
      </p>

      <pre class="example nohighlight" title="자연어 텍스트를 영어로 표현">
"title": {
  "value": "<span class="highlight">HTML and CSS: Designing and Creating Websites</span>",
  "lang": "<code>en</code>"
}
      </pre>

      <p>
        다음 예는 오른쪽에서 왼쪽으로 기본 방향으로 아랍어로 표현 된 유사한 제목을 사용한다.
      </p>

      <pre class="example nohighlight" title="기본 방향이 오른쪽에서 왼쪽 인 아랍어 텍스트">
"title": {
  "value": "<span class="highlight">HTML و CSS: تصميم و إنشاء مواقع الويب</span>",
  "lang": "<code>ar</code>"
  "dir": "<code>rtl</code>"
}
      </pre>

      <p class="note">
        많은 시스템에서 텍스트 문자열의 첫 번째 문자를 사용하여 텍스트 방향을 결정하므로
        위의 텍스트는 언어와 방향을 명시적으로 표현하지 않고 왼쪽에서 오른쪽으로 잘못 표시된다.
      <p>

      <p>
        JSON-LD를 사용하는 구현자는
        국제화 된 <a>속성</a>을 정의하는 JSON-LD 컨텍스트를 <a href="#extensibility">extend</a>하고
        JSON-LD의 범위
        지정된 컨텍스트 기능을 사용하여
        <code>@value</code>, <code>@language</code> 및 <code>@direction</code> 키워드를
        <code>value</code>, <code>lang</code> 및 <code>dir</code>로 별명
        지정해야한다. 각기. 이를 수행하는 JSON-LD 컨텍스트 스니펫의 예는 다음과 같다.
      </p>

      <pre class="example nohighlight" title="언어 정보에 대한 범위 별명 지정">
"title": {
  <span class="highlight">"@context": {"value": "@value", "lang": "@language", "dir": "@direction"}</span>,
  "@id": "https://www.w3.org/2018/credentials/examples#title"
}
      </pre>

    </section>

    <section class="informative">
      <h3>Complex Language Markup</h3>

      <p>
        여러 언어, 기본 방향 및 주석이 단일 자연 언어 문자열로 사용되는 경우
        일반적으로 더 복잡한 메커니즘이 필요하다.
        HTML과 같은 마크 업 언어를 사용하여 여러 언어와 기본 방향으로 텍스트를 인코딩 할 수 있다.
        <code>rdf : HTML</code> 데이터 유형을 사용하여 이러한 값을 JSON-LD로 정확하게 인코딩 할 수도 있다.

      </p>

      <p>
        정보를 HTML로 인코딩하는 기능에도 불구하고 구현자는 다음과 같은 이유로 이 작업을 수행하지 않는 것이 좋다.
      </p>

      <ul>
        <li>
          일부 버전의 HTML 프로세서가 필요하므로 언어 및 기본 방향 정보 처리 부담이 증가한다.
        </li>
        <li>
          HTML을 맹목적으로 처리하면 데이터 생성 프로세스 중 공격자가 어느 시점에 삽입 한
          <code>script</code> 태그가 실행될 수 있으므로 이 데이터 모델을 사용할 때 보안 공격 영역이 증가한다.
        </li>
      </ul>

      <p>
        구현자가 특정 사용 사례를 해결하기 위해
        HTML 또는 실행 가능한 스크립트를 포함 할 수있는 다른 마크 업 언어를 사용해야한다고 생각하는 경우,
        구현자는 공격자가 어떻게 마크 업을 사용하여 마크 업 소비자에 대한 인젝션 공격을 마운트 하는지 분석 후
        식별된 공격에 대한 완화를 배포 한다.
      </p>
    </section>

  </section>

  <section class="appendix informative" id="validation">
    <h2>검증</h2>

    <p>
      이 사양은 <a>검증가능한 크리덴셜</a> 또는 <a>검증가능한 프레젠테이션</a>의 <a>검증</a> 프로세스에 대한 적합성 기준을
      제공하지는 않지만 독자는 <a>유효성 검사</a>에서 <a>검증자</a>가 이 데이터 모델의 정보를 어떻게 활용할지 궁금 할 것이다.
      이 섹션에서는 <a>검증자</a>가이 사양에서 예상되는 데이터 필드 사용과 관련하여 실무 그룹(working group)이 보유한
      대화를 공유(capture)한다.
    </p>

    <section class="informative" id="credential-subject">
      <h3>크리덴셜 주체</h3>

      <p>
        <a>보유자</a>가 제시 한 <a>검증가능한 크리덴셜</a>에서
        각 <code>credentialSubject</code>의 <a>id</a> <a>속성</a>과 연관된 값은 <a>검증자</a>에게
        <a>주체</a>를 식별해야 한다. <a>보유자</a>가 <a>주체</a>인 경우, <a>검증자</a>는 <a>보유자</a>와 관련된 공개 키 메타 데이터가있는 경우
        <a>보유자</a>를 인증 할 수 있다. <a>검증자</a>는 <a>검증가능한 프레젠테이션</a>에 포함 된 <a>보유자</a>에 의해 생성 된 서명을
        사용하여 <a>보유자</a>를 인증 할 수있다. <a>id</a> <a>속성</a>은 선택 사항이다. <a>검증자</a>는 <a>검증가능한 크리덴셜</a>에서 다른
        <a>속성들</a>을 사용하여 <a>주체</a>를 고유하게 식별 할 수 있다.
      </p>

      <p class="note">
        인증 및 WebAuthn이 <a>검증가능한 크리덴셜</a>로 작동하는 방법에 대한 자세한 내용은
        검증가능한 크리덴셜 구현 지침 [[VC-IMP-GUIDE]] 문서를 참조.
      </p>

    </section>

    <section class="informative" id="issuer">
      <h3>발급자</h3>

      <p>
        <code>issuer</code> <a>속성</a>과 관련된 값은 <a>검증자</a>에게 알려지고 신뢰할 수있는 <a>발급자</a>를 식별해야한다.
      </p>

      <p>
        <code>issuer</code> <a>속성</a>에 대한 관련 메타 데이터가 <a>검증자</a>에게 제공 될 것으로 예상된다.
        예를 들어, <a>발급자</a>는 발급 한 <a>검증가능한 크리덴셜</a>을 디지털 서명하는 데 사용하는 공개 키가
        포함 된 정보를 게시 할 수 있다. 이 메타 데이터는 <a>검증가능한 크리덴셜</a>에서 증명을 확인할 때 관련이 있다.
      </p>
    </section>

    <section class="informative" id="issuance-date">
      <h3>발급 날짜</h3>

      <p>
        <code>issuanceDate</code>는 <a>검증자</a>의 예상 범위 내에 있어야한다.
        예를 들어, <a>검증자</a>는 <a>검증가능한 크리덴셜</a>의 발급 날짜가 미래에 있지 않은지 확인할 수 있다.
      </p>
    </section>
    <section class="informative" id="proofs-signatures-0">
      <h3>증명 (서명)</h3>
      <p> 
        <a>검증가능한 크리덴셜</a>
        또는 <a>검증가능한 프레젠테이션</a>의
        정보가 변조되지 않았음을 증명하는 데 사용되는 암호화 메커니즘을
        <em>증명</em>이라고 하자. 디지털 서명, 영지식 증명, 작업증명,
        지분증명 등을 포함하는 다양한 유형의 암호화 증명이 있다.
        일반적으로 증명을 검증할 때, 구현시 다음을 보장해야 한다:
      </p>
      <ul>
        <li>증명은 알려진 증명 모음의 형식으로 이용 가능하다.
        </li>
        <li>모든 필수 증명 모음 <a>속성</a>들이 존재한다.
        </li>
        <li>증명 모음 <a>검증</a>
          알고리즘이 데이터에 적용되면 유효한 증명이 산출된다.
        </li>
      </ul>
      <p>어떤 증명은 디지털 서명이다. 일반적으로 디지털 서명을 검증할 때,
        구현시 다음을 보장해야 한다:</p>
      <ul>
        <li>서명과 관련된 공개 키에 관한 최신 메타 데이터를 사용할 수 있다.
          메타 데이터에는 만료, 키 소유자 또는 키 목적과 관련된 <a>속성</a>
          등이 포함될 수 있다.</li>
        <li>키는 중단되거나 취소 또는 만료되지 않는다.</li>
        <li>암호화된 서명은 검증되어야 한다.</li>
        <li>암호화 모음이 <code>proofPurpose</code> <a>속성</a>을
          필요로 한다면
          해당 속성은 존재해야 하고 <code>assertionMethod</code>와 같은
          유효한 값이어야 한다.
        </li>
      </ul>
      <div class="note" role="note" id="issue-container-generatedID-37">
        <div role="heading" class="note-title marker" id="h-note-37" aria-level="4">
        </div>
        <p class="">디지털 서명은 위변조 방지 외에도 여러가지 보호 기능을 제공한다.
          예를 들어 연결된 데이터 서명 <code>created</code> <a>속성</a>은
          <a>크리덴셜</a>이
          아직 <a>검증된</a> 상태가 아닌 것으로
          간주되어야 할 날짜와 시간을 설정한다. The <code>verificationMethod</code>
          <a>
            속성</a>속성은 디지털 서명을 확인하는데 사용될 수 있는 공개키를 지정한다.
          공개키 URL을 참조 해제하면 키의 컨트롤러에 대한 정보가 표시되며,
          이 정보는 <a>크리덴셜</a> 발행자에 대해 확인할 수 있다.
          <code>proofPurpose</code>
          <a>속성</a>은 증명 목적을 명확하게 표현하고, 이 정보가 서명으로
          보호되도록 보장한다. 일반적으로 증명은 인증 목적으로
          <a>검증가능한 프레젠테이션</a>에 첨부되거나
          인증 보장의 방법으로써 <a>검증가능한 크리덴셜</a>에
          첨부된다.</p>
      </div>
    </section>
    <section class="informative" id="expiration-0">
      <h3>만료</h3>
      <p><code>expirationDate</code>은 <a>verifier</a>의 예상
        범위 안에
        있어야 한다. 예를 들어 <a>verifier</a>는 <a>검증가능한 크리덴셜</a>의
        만료 날짜가 과거 날짜가 아닌지 확인할 수 있다.</p>
    </section>
    <section class="informative" id="status-0">
      <h3>상태</h3>
      <p><code>credentialStatus</code>이 사용 가능한 경우, <a>검증가능한 크리덴셜</a>의 상태는 검증가능한
        크리덴셜에 대한 <code>credentialStatus</code> <a>타입</a> 정의 및
        <a>검증자</a>의
        평가 기준에 따라 <a>검증자</a>에
        의해 평가되어야 한다. 예를 들어, <a>검증자</a>는 <a>검증가능한 크리덴셜</a>의 상태가 "<a>발급자</a>에 의해 취소됨"이
        아니라는 것을 보장할 수 있다.</p>
    </section>
    <section class="informative" id="fitness-for-purpose">
      <h3>목적 적합성</h3>
      <p>목적 적합성은 <a>검증가능한 크리덴셜</a>의
        사용자 지정 <a>속성</a>이 <a>검증자</a>의 목적에 적합한지
        여부이다. 예를 들어 <a>주체</a>가 21세 이상인지 <a>검증자</a>가 확인해야 하는 경우
        지정된 <code>birthdate</code> <a>속성</a> 또는
        <code>ageOver</code> 와 같은
        보다 추상적인 <a>속성</a>에 의존할 수 있다.</p>
      <p>
        <a>발행자</a>는 즉시 <a>클레임</a>을 생성할 수 있도록
        <a>검증자</a>로부터 신뢰를 얻는다. 예를 들어, 프랜차이즈 패스트푸드
        식당 위치는 프랜차이즈 본사에서 만든 항린 쿠폰 <a>클레임</a>을 신뢰한다.
        <a>발급자</a>가 <a>검증가능한 크리덴셜</a>에 표현한
        정책 정보는,
        정책에 위배되는 책임을 용인하지 않는 한 <a>보유자</a>와 <a>검증자</a>에 의해 존중되어야 한다.</p>
    </section>
  </section>

  <section class="appendix informative">
    <h2>Base Context</h2>
    <code>https://www.w3.org/2018/credentials/v1</code>에 있고 SHA-256 다이제스트
    <strong><code>ab4ddd9a531758807a79a5b450510d61ae8d147eab966cc9a200c07095b0cdcc</code></strong> 를 갖는 기본 컨텍스트는 로컬 캐시
    복사본을 구현하는데 사용될 수 있다. 편의상 이번 장에서는 기본 컨텍스트가 함께 제공한다.
    </p>

    <pre class="informative">
{
  "@context": {
    "@version": 1.1,
    "@protected": true,

    "id": "@id",
    "type": "@type",

    "VerifiableCredential": {
      "@id": "https://www.w3.org/2018/credentials#VerifiableCredential",
      "@context": {
        "@version": 1.1,
        "@protected": true,

        "id": "@id",
        "type": "@type",

        "cred": "https://www.w3.org/2018/credentials#",
        "sec": "https://w3id.org/security#",
        "xsd": "http://www.w3.org/2001/XMLSchema#",

        "credentialSchema": {
          "@id": "cred:credentialSchema",
          "@type": "@id",
          "@context": {
            "@version": 1.1,
            "@protected": true,

            "id": "@id",
            "type": "@type",

            "cred": "https://www.w3.org/2018/credentials#",

            "JsonSchemaValidator2018": "cred:JsonSchemaValidator2018"
          }
        },
        "credentialStatus": {"@id": "cred:credentialStatus", "@type": "@id"},
        "credentialSubject": {"@id": "cred:credentialSubject", "@type": "@id"},
        "evidence": {"@id": "cred:evidence", "@type": "@id"},
        "expirationDate": {"@id": "cred:expirationDate", "@type": "xsd:dateTime"},
        "holder": {"@id": "cred:holder", "@type": "@id"},
        "issued": {"@id": "cred:issued", "@type": "xsd:dateTime"},
        "issuer": {"@id": "cred:issuer", "@type": "@id"},
        "issuanceDate": {"@id": "cred:issuanceDate", "@type": "xsd:dateTime"},
        "proof": {"@id": "sec:proof", "@type": "@id", "@container": "@graph"},
        "refreshService": {
          "@id": "cred:refreshService",
          "@type": "@id",
          "@context": {
            "@version": 1.1,
            "@protected": true,

            "id": "@id",
            "type": "@type",

            "cred": "https://www.w3.org/2018/credentials#",

            "ManualRefreshService2018": "cred:ManualRefreshService2018"
          }
        },
        "termsOfUse": {"@id": "cred:termsOfUse", "@type": "@id"},
        "validFrom": {"@id": "cred:validFrom", "@type": "xsd:dateTime"},
        "validUntil": {"@id": "cred:validUntil", "@type": "xsd:dateTime"}
      }
    },

    "VerifiablePresentation": {
      "@id": "https://www.w3.org/2018/credentials#VerifiablePresentation",
      "@context": {
        "@version": 1.1,
        "@protected": true,

        "id": "@id",
        "type": "@type",

        "cred": "https://www.w3.org/2018/credentials#",
        "sec": "https://w3id.org/security#",

        "holder": {"@id": "cred:holder", "@type": "@id"},
        "proof": {"@id": "sec:proof", "@type": "@id", "@container": "@graph"},
        "verifiableCredential": {"@id": "cred:verifiableCredential", "@type": "@id", "@container": "@graph"}
      }
    },

    "EcdsaSecp256k1Signature2019": {
      "@id": "https://w3id.org/security#EcdsaSecp256k1Signature2019",
      "@context": {
        "@version": 1.1,
        "@protected": true,

        "id": "@id",
        "type": "@type",

        "sec": "https://w3id.org/security#",
        "xsd": "http://www.w3.org/2001/XMLSchema#",

        "challenge": "sec:challenge",
        "created": {"@id": "http://purl.org/dc/terms/created", "@type": "xsd:dateTime"},
        "domain": "sec:domain",
        "expires": {"@id": "sec:expiration", "@type": "xsd:dateTime"},
        "jws": "sec:jws",
        "nonce": "sec:nonce",
        "proofPurpose": {
          "@id": "sec:proofPurpose",
          "@type": "@vocab",
          "@context": {
            "@version": 1.1,
            "@protected": true,

            "id": "@id",
            "type": "@type",

            "sec": "https://w3id.org/security#",

            "assertionMethod": {"@id": "sec:assertionMethod", "@type": "@id", "@container": "@set"},
            "authentication": {"@id": "sec:authenticationMethod", "@type": "@id", "@container": "@set"}
          }
        },
        "proofValue": "sec:proofValue",
        "verificationMethod": {"@id": "sec:verificationMethod", "@type": "@id"}
      }
    },

    "EcdsaSecp256r1Signature2019": {
      "@id": "https://w3id.org/security#EcdsaSecp256r1Signature2019",
      "@context": {
        "@version": 1.1,
        "@protected": true,

        "id": "@id",
        "type": "@type",

        "sec": "https://w3id.org/security#",
        "xsd": "http://www.w3.org/2001/XMLSchema#",

        "challenge": "sec:challenge",
        "created": {"@id": "http://purl.org/dc/terms/created", "@type": "xsd:dateTime"},
        "domain": "sec:domain",
        "expires": {"@id": "sec:expiration", "@type": "xsd:dateTime"},
        "jws": "sec:jws",
        "nonce": "sec:nonce",
        "proofPurpose": {
          "@id": "sec:proofPurpose",
          "@type": "@vocab",
          "@context": {
            "@version": 1.1,
            "@protected": true,

            "id": "@id",
            "type": "@type",

            "sec": "https://w3id.org/security#",

            "assertionMethod": {"@id": "sec:assertionMethod", "@type": "@id", "@container": "@set"},
            "authentication": {"@id": "sec:authenticationMethod", "@type": "@id", "@container": "@set"}
          }
        },
        "proofValue": "sec:proofValue",
        "verificationMethod": {"@id": "sec:verificationMethod", "@type": "@id"}
      }
    },

    "Ed25519Signature2018": {
      "@id": "https://w3id.org/security#Ed25519Signature2018",
      "@context": {
        "@version": 1.1,
        "@protected": true,

        "id": "@id",
        "type": "@type",

        "sec": "https://w3id.org/security#",
        "xsd": "http://www.w3.org/2001/XMLSchema#",

        "challenge": "sec:challenge",
        "created": {"@id": "http://purl.org/dc/terms/created", "@type": "xsd:dateTime"},
        "domain": "sec:domain",
        "expires": {"@id": "sec:expiration", "@type": "xsd:dateTime"},
        "jws": "sec:jws",
        "nonce": "sec:nonce",
        "proofPurpose": {
          "@id": "sec:proofPurpose",
          "@type": "@vocab",
          "@context": {
            "@version": 1.1,
            "@protected": true,

            "id": "@id",
            "type": "@type",

            "sec": "https://w3id.org/security#",

            "assertionMethod": {"@id": "sec:assertionMethod", "@type": "@id", "@container": "@set"},
            "authentication": {"@id": "sec:authenticationMethod", "@type": "@id", "@container": "@set"}
          }
        },
        "proofValue": "sec:proofValue",
        "verificationMethod": {"@id": "sec:verificationMethod", "@type": "@id"}
      }
    },

    "RsaSignature2018": {
      "@id": "https://w3id.org/security#RsaSignature2018",
      "@context": {
        "@version": 1.1,
        "@protected": true,

        "challenge": "sec:challenge",
        "created": {"@id": "http://purl.org/dc/terms/created", "@type": "xsd:dateTime"},
        "domain": "sec:domain",
        "expires": {"@id": "sec:expiration", "@type": "xsd:dateTime"},
        "jws": "sec:jws",
        "nonce": "sec:nonce",
        "proofPurpose": {
          "@id": "sec:proofPurpose",
          "@type": "@vocab",
          "@context": {
            "@version": 1.1,
            "@protected": true,

            "id": "@id",
            "type": "@type",

            "sec": "https://w3id.org/security#",

            "assertionMethod": {"@id": "sec:assertionMethod", "@type": "@id", "@container": "@set"},
            "authentication": {"@id": "sec:authenticationMethod", "@type": "@id", "@container": "@set"}
          }
        },
        "proofValue": "sec:proofValue",
        "verificationMethod": {"@id": "sec:verificationMethod", "@type": "@id"}
      }
    },

    "proof": {"@id": "https://w3id.org/security#proof", "@type": "@id", "@container": "@graph"}
  }
}
</pre>

  </section>

  <section class="informative appendix" id="subject-holder-relationships">
    <h3>주체-보유자 관계</h3>

    <p>
      이 섹션에서는 <a>주체</a>와 <a>보유자</a> 간의 성립 가능한 관계와 <a>검증가능한 크리덴셜</a>
      데이터 모델이 이러한 관계를 어떻게 표현하는지 설명한다. 다음 다이어그램은 이러한 관계를 보여주며, 
      다음 섹션에서는 이 관계가 데이터 모델에서 처리되는 방식을 설명한다.
    </p>

    <figure>
      <img style="margin: auto; display: block; width: 75%;" src="diagrams/subject-ne-holder.svg" alt="Long decision tree
          from top to bottom.  For the first question, 'Subject
          Present?', No means Bearer Credential and Yes points to the
          rest of the tree.  From this point on until the very end,
          each Yes points to an answer and each No points to another
          question.  The first question here is 'Subject = Holder?',
          with Yes meaning Most Common Use Case.  If No, 'Credential
          Uniquely Identifies Subject?' with Yes meaning Irrelevant who
          Holder is.  If No, 'Subject Passes VC to Holder?' with Yes
          meaning, e.g., Power of Attorney, Employee.  If No, 'Issuer
          Independently Authorizes Holder?' with Yes meaning, e.g., Law
          Enforcement.  If No, 'Holder Acts for Subject?' with Yes
          meaning, e.g., Parent, Pet Owner, Travel Agent.  If No,
          'Holder Acts for Verifier?' with Yes meaning, e.g., Recruiter
          passing on VC of job applicant to employer and No meaning
          'Random Holder with no relationship to Subject, Issuer or Verifier">
      <figcaption style="text-align: center;">
        Subject-Holder Relationships in Verifiable Credentials.
      </figcaption>
    </figure>
    <section class="informative">
      <h4>주체가 보유자</h4>

      <p>
        가장 일반적인 관계는 <a>주체</a>가
        <a>보유자</a>인
        경우이다. 이 경우에 만약 <a>검증가능한
          프레젠테이션</a>이
        <a>보유자</a>에
        의해 디지털 서명 되어있고, 포함된 모든 <a>검증가능한 크리덴셜</a>이 <a>보유자</a>와 동일한 것으로 식별되는 <a>주체</a>에 관한 것이라면 
        <a>검증자</a>는 그 <a>주체</a>가 <a>보유자</a>라고 쉽게 추론할 수 있다.
      </p>

      <p>
        만약 <code>credentialSubject</code>만이 <a>검증가능한 크리덴셜</a>을 <a>검증가능한 프레젠테이션</a>에 삽입할 수 있는 경우, 
        <a>발급자</a>는
        아래에 설명된대로 <a>검증가능한 크리덴셜</a>에
        <code>nonTransferable</code> <a>속성</a>을 삽입할 수 있다.
      </p>

      <section class="informative">
        <h5>nonTransferable 속성</h5>

        <p>
          <code>nonTransferable</code> <a>속성</a>은
          <a>검증가능한 크리덴셜</a>을
          <code>credentialSubject</code>의해 발행된 증명을 가진 <a>검증가능한 프레젠테이션</a>에만 캡슐화해야 함을 나타낸다. 
          <code>nonTransferable</code> <a>속성</a>이 없고 증명작성자가 <code>credentialSubject</code>가 아닌 
          <a>검증가능한 크리덴셜</a>을 포함하는 <a>검증가능한 프레젠테이션</a>은 유효하지 않다.
        </p>

        <pre class="example nohighlight" title="nonTransferable 속성의 사용">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "ProofOfAgeCredential"],
  "issuer": "https://example.edu/issuers/14",
  "issuanceDate": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "ageOver": 21
    },
  "nonTransferable": "True",
  "proof": { ..
  "verificationMethod": "did:example:ebfeb1f712ebc6f1c276e12ec21",
  ... }
}
          </pre>
      </section>
    </section>

    <section class="informative" id="credential-uniquely-identifies-a-subject">
      <h4>주체를 고유하게 식별하는 크리덴셜</h4>

      <p>
        이 경우 <code>credentialSubject</code> <a>속성</a>은 <a>주체</a>의 여러 측면을 설명하는
        다수의 <a>속성</a>이 포함될 수 있으며
        그<a>주체</a>를 명확하게 식별하기 위해 결합된다. 일부 활용 사례는 의사(<a>주체</a>)가 보드-인증을 받았는지 확인하는 것과 같이
        <a>보유자</a>를 전혀 식별하지 않을 수 있다.
        다른 사용 사례에서는 <a>검증자</a>가 <a>주체</a>와 <a>보유자</a>사이의 관계를 결정하기 위해 범위 밖 지식을 사용해야 할 수 있다.
      </p>

      <pre class="example nohighlight" title="A credential uniquely identifying a subject">
{
  "@context": ["https://www.w3.org/2018/credentials/v1", "https://schema.org/"]
  "id": "http://example.edu/credentials/332",
  "type": ["VerifiableCredential", "IdentityCredential"],
  "issuer": "https://example.edu/issuers/4",
  "issuanceDate": "2017-02-24T19:73:24Z",
  "credentialSubject": {
    "name": "J. Doe",
    "address": {
      "streetAddress": "10 Rue de Chose",
      "postalCode": "98052",
      "addressLocality": "Paris",
      "addressCountry": "FR"
    },
    "birthDate": "1989-03-15"
    ...
  },
  "proof": { <span class="comment">...</span> }
}
        </pre>

      <p>
        위의 예는 개인의 이름, 주소, 생년월일을 이용하여<a>주체</a>를 고유하게 식별한다.
      </p>
    </section>

    <section class="informative" id="subject-passes-the-verifiable-credential-to-a-holder">
      <h4>주체가 검증가능한 크리덴셜을 보유자에게 전달</h4>

      <p>
        일반적으로 <a>검증가능한 크리덴셜</a>은 <a>주체</a>에 의하여
        <a>검증자</a>에게 제공된다. 그러나, 경우에 따라서, <a>주체</a>는
        다른 <a>보유자</a>에게 <a>검증가능한 크리덴셜</a>의 전체 또는 일부를 전달해야 할지도 모른다.
        예를 들어, 만약 환자 (<a>주체</a>) 너무 아파서
        약사 (<a>검증자</a>)에게 처방전 (<a>검증가능한 크리덴셜</a>)을 받을 수 없는 경우,
        그의 친구가 약을 수령하기 위해 처방전을 가져갈 수도 있다.
      </p>

      <p>
        데이터 모델은 <a>주체</a>가
        새로운<a>검증가능한 크리덴셜</a>을 발급하여 새로운 <a>보유자</a>에게 전달하고,
        새로운 <a>보유자</a>는 두 개의 <a>검증가능한 크리덴셜</a>을
        <a>검증자</a>에게 제시할 수 있도록 함으로써 이를 가능하게 한다.
        하지만, 두 번째 <a>검증가능한 크리덴셜</a>의 내용은 어플리케에션별로 다를 수 있으며,
        이 규격은 두 번째 <a>검증가능한 크리덴셜</a>의 내용을 표준화할 수 없다.
        그럼에도 불구하고, 비표준적인 예가 수록되어 있다.
        <a href="#subject-passes-a-verifiable-credential-to-someone-else"></a>.
      </p>

    </section>

    <section class="informative" id="holder-acts-on-behalf-of-the-subject">
      <h4>보유자가 주체를 대신하여 실행</h4>

      <p>
        ‘검증가능한 크리덴셜 데이터 모델’은 최소한 다음과 같은 방법으로<a>주체</a>를 대신하여
        <a>보유자</a>를 지원한다.
      </p>

      <ul>
        <li>
          <a>발급자</a>는 <code>credentialSubject</code> <a>속성</a>에 <a>보유자</a>와
          <a>주체</a> 사이의 관계를 포함할 수 있다.
        </li>

        <li>
          <a>발급자</a>는 <a>보유자</a>가 활용하는 새로운 <a>검증가능한 크리덴셜</a>을 발급함으로써 <a>보유자</a>와
          <a>주체</a> 사이에 관계를 표현할 수 있다.
        </li>

        <li>
          <a>주체</a>는 <a>보유자</a>가 활용하는 새로운
          <a>검증가능한 크리덴셜</a>의 발급함으로써 <a>보유자</a>와의 관계를 표현할 수 있다.
        </li>
      </ul>

      <p>
        위에 열거된 매커니즘은 <a>보유자</a>와 <a>주체</a> 사이의 관계를 설명하고,
        <a>검증자</a>가 주어진 사용 사례에서 충분히 표현되는지 여부를 결정하도록 돕는다.
      </p>

      <p class="note">
        <a>발급자</a> 혹은 <a>검증자</a>가
        <a>주체</a>와 <a>보유자</a> 사이의 검증하기 위해 사용하는 추가적인 매커니즘은 이 규격의 범위를 벗어난다.
      </p>

      <pre class="example nohighlight" title="The relationship property in a child's credential">{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "AgeCredential", "RelationshipCredential"],
  "issuer": "https://example.edu/issuers/14",
  "issuanceDate": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "ageUnder": 16,
    "parent": {
      "id": "did:example:ebfeb1c276e12ec211f712ebc6f",
      "type": "Mother"
    }
  },
  "proof": { <span class="comment">...</span> }  <span class="comment">// the proof is generated by the DMV</span>
}
        </pre>

      <p>
        위의 예에서, <a>발급자</a>는 <a>검증자</a>가 <a>크리덴셜</a>을 아이 혹은 부모가 제공하는 경우에
        가장 쉽게 수락할 수 있도록 아이와 부모 사이의 관계를 표현한다.
      </p>

      <pre class="example nohighlight" title="부모에게 발급된 크리덴셜 관계">{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "RelationshipCredential"],
  "issuer": "https://example.edu/issuers/14",
  "issuanceDate": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1c276e12ec211f712ebc6f",
    "child": {
      "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
      "type": "Child"
    }
  },
  "proof": { <span class="comment">...</span> } <span class="comment">// the proof is generated by the DMV</span>
}
        </pre>

      <p>
        위의 예에서, <a>발급자</a>는 <a>검증자</a>가 아이에 의해 제공된
        <a>크리덴셜</a> 혹은 위의 <a>크리덴셜</a>이 함께 제공된 아이의 <a>크리덴셜</a>을
        대부분을 수락할 수 있도록 아이와 부모 사이의 관계를 별도의 <a>크리덴셜</a>로 표현한다.
      </p>

      <pre class="example nohighlight" title="아이에 의해 발급된 크리덴셜 관계">{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.org/credentials/23894",
  "type": ["VerifiableCredential", "RelationshipCredential"],
  "issuer": "http://example.org/credentials/23894",
  "issuanceDate": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "parent": {
      "id": "did:example:ebfeb1c276e12ec211f712ebc6f",
      "type": "Mother"
    }
  },
  "proof": { <span class="comment">...</span> } <span class="comment">// the proof is generated by the child</span>
}
        </pre>

      <p>
        위의 예에서, 아이는 <a>검증자</a>가 위의 <a>크리덴셜</a>이 제공될 경우
        아이의 <a>크리덴셜</a>을 가장 잘 받아들여질 수 있도록 아이와 부모 사이의 관계를
        별도의 <a>크리덴셜</a>로 표현한다.
      </p>

      <p>
        마찬가지로, 위에 예시에서 묘사된 전략은 대리인의 권한,
        애완동물에 소유권 및 환자 처방전 대리수령(pick up)을
        포함한 사용 사례의 많은 다른 종류를 위해 사용될 수 있다.
      </p>

    </section>

    <section class="informative" id="subject-passes-a-verifiable-credential-to-someone-else">
      <h3>주체가 검증가능한 크리덴셜을 다른 누군가에게 전달</h3>

      <p>
        <a>주체</a>가 다른 <a>보유자</a>에게
        <a>검증가능한 크리덴셜</a>을 전달하면, 그<a>주체</a>는 새로운 <a>검증가능한 크리덴셜</a>을
        다음 사항이 적용되는<a>보유자</a>에게 발급할 수 있다.
      </p>

      <ul>
        <li>
          <a>발급자</a>가 <a>주체</a>일 때
        </li>

        <li>
          <a>주체</a>가 <a>검증가능한 크리덴셜</a>이 통과된 <a>보유자</a> 일 때
        </li>

        <li>
          <a>클레임</a>에 전달되는 <a>속성</a>이 포함되어 있을 때
        </li>
      </ul>

      <p>
        <a>보유자</a>는 두 개의<a>검증가능한 크리덴셜</a>을 포함하는
        새로운 <a>검증가능한 프레젠테이션</a>을 생성하여 <a>검증자</a>는
        <a>주체</a>가 기존의 <a>보유자</a>에게 원본 <a>검증가능한 크리덴셜</a>을 부여했는지를 검증할 수 있다.
      </p>

      <pre class="example nohighlight" title="A holder presenting a
verifiable credential that was passed to it by the subject">
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "did:example:76e12ec21ebhyu1f712ebc6f1z2",
  "type": ["VerifiablePresentation"],
  "verifiableCredential": [
    {
     "@context": [
       "https://www.w3.org/2018/credentials/v1",
       "https://www.w3.org/2018/credentials/examples/v1"
      ],
      "id": "http://example.gov/credentials/3732",
      "type": ["VerifiableCredential", "PrescriptionCredential"],
      "issuer": "https://example.edu",
      "issuanceDate": "2010-01-01T19:73:24Z",
      "credentialSubject": {
        "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
        "prescription": {....}
      },
      "revocation": {
        "id": "http://example.gov/revocations/738",
        "type": "SimpleRevocationList2017"
      },
      "proof": {....}
    },
    {
      "@context": [
        "https://www.w3.org/2018/credentials/v1",
        "https://www.w3.org/2018/credentials/examples/v1"
      ],
      "id": "https://example.com/VC/123456789",
      "type": ["VerifiableCredential", "PrescriptionCredential"],
      "issuer": "did:example:ebfeb1f712ebc6f1c276e12ec21",
      "issuanceDate": "2010-01-03T19:73:24Z",
      "credentialSubject": {
        "id": "did:example:76e12ec21ebhyu1f712ebc6f1z2",
        "prescription": {....}
      },
      "proof": {
        "type": "RsaSignature2018",
        "created": "2018-06-17T10:03:48Z",
        "proofPurpose": "assertionMethod",
        "jws": "pYw8XNi1..Cky6Ed=",
        "verificationMethod": "did:example:ebfeb1f712ebc6f1c276e12ec21/keys/234"
      }
    }
  ],
  "proof": [{
    "type": "RsaSignature2018",
    "created": "2018-06-18T21:19:10Z",
    "proofPurpose": "authentication",
    "verificationMethod": "did:example:76e12ec21ebhyu1f712ebc6f1z2/keys/2",
    "challenge": "c0ae1c8e-c7e7-469f-b252-86e6a0e7387e",
    "jws": "BavEll0/I1..W3JT24="
  }]
}
      </pre>

      <p>
        위에 예시에서, 환자 (기존의 <a>주체</a>)가 친구에게
        처방전(기존의 <a>검증가능한 크리덴셜</a>)을 전달했고 친구에게
        새로운<a>검증가능한 크리덴셜</a>을 발급했고
        친구가 <a>주체</a>인 경우, 기존의 <a>검증가능한 크리덴셜</a>의
        <a>주체</a>는 <a>발급자</a>이며 그<a>크리덴셜</a>은
        기존 처방전의 사본이다.
      </p>

    </section>

    <section class="informative" id="issuer-authorizes-holder">
      <h4>발급자가 보유자에게 허가하기</h4>

      <p>
        <a>발급자</a>가 <a>보유자</a>가 아닌
        <a>주체</a>로 설명하는 <a>크리덴셜</a>을 <a>보유자</a>에게 부여하고
        <a>보유자</a>는 <a>주체</a>와 알려진 관계가 없는 경우,
        그리고 나서 <a>발급자</a>는 <a>주체</a>의 <a>크리덴셜</a>에
        <a>보유자</a>의 관계를 삽입할 수 있다.
      </p>

      <p class="note">
        검증가능한 크리덴셜은 인증 프레임워크가 아니므로, 위임은 이 규격 범위를 벗어난다.
        단, 검증가능한 크리덴셜이 인증과 위임시스템을 구축하기위해 사용될 가능성을 있는 것으로 이해된다.
        다음은 일부 사용 사례에 적합할 수 있는 한 가지 접근법이다.
      <p>

      <pre class="example nohighlight" title="A credential issued to a
holder who is not the (only) subject of the credential, who has no relationship with
the subject of the credential, but who has a relationship with the issuer">

{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.edu/credentials/3732",
  "type": ["VerifiableCredential", "NameAndAddress"],
  "issuer": "https://example.edu/issuers/14",
  "holder": {
    "type": "LawEnforcement",
    "id": "did:example:ebfeb1276e12ec21f712ebc6f1c"
  },
  "issuanceDate": "2010-01-01T19:73:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "name": "Mr John Doe",
    "address": "10 Some Street, Anytown, ThisLocal, Country X"
  },
  "proof": {
    "type": "RsaSignature2018",
    "created": "2018-06-17T10:03:48Z",
    "proofPurpose": "assertionMethod",
    "verificationMethod": "https://example.edu/issuers/14/keys/234",
    "jws": "pY9...Cky6Ed = "
  }
}
        </pre>
    </section>

    <section class="informative" id="holder-acts-on-behalf-of-the-verifier-or-has-no-relationship-with-the-subject-issuer-or-verifier">
      <h4>보유자가 검증자를 대신하여 실행, 또는 보유자가 주체, 발급자, 검증자와 관련없음</h4>

      <p>
        검증가능한 크리덴셜 데이터 모델은 이런 시나리오를 지원하지 않는다. 어떻게 지원할 수 있는지에 대해서는 추가적인 연구가 필요하다.
      </p>
    </section>

  </section>

  <section class="appendix informative" id="iana-considerations">
    <h2>IANA 고려사항</h2>
    <p>
      이 섹션은 검토, 승인, IANA의 “JSON Web Token Claims Registry” 등록을 위하여 
      인터넷 엔지니어링 스티어링 그룹(Internet Engineering Steering Group, IESG)에 제출될 것이다.
    </p>

    <ul>
      <li>Claim Name: "vc"</li>
      <li>Claim Description: Verifiable Credential</li>
      <li>Change Controller: W3C</li>
      <li>Specification Document(s):
        <a href="https://www.w3.org/TR/vc-data-model/">Section 6.3.1.2: JSON Web Token
          Extensions of Verifiable Credentials Data Model 1.0</a>
      </li>
    </ul>

    <ul>
      <li>Claim Name: "vp"</li>
      <li>Claim Description: Verifiable Presentation</li>
      <li>Change Controller: W3C</li>
      <li>Specification Document(s):
        <a href="https://www.w3.org/TR/vc-data-model/">Section 6.3.1.2: JSON Web Token
          Extensions of Verifiable Credentials Data Model 1.0</a>
      </li>
    </ul>

  </section>

  <section class="appendix informative">
    <h2>Acknowledgements</h2>

    <p>
      The Working Group would like to thank the following individuals for reviewing
      and providing feedback on the specification (in alphabetical order):
    </p>

    <p>
      Christopher Allen, David Ammouial, Joe Andrieu, Bohdan Andriyiv, Ganesh
      Annan, Kazuyuki Ashimura, Tim Bouma, Pelle Braendgaard, Dan Brickley,
      Allen Brown, Jeff Burdges, Daniel Burnett, ckennedy422, David Chadwick,
      Chaoxinhu, Kim (Hamilton) Duffy, Lautaro Dragan, enuoCM, Ken Ebert, Eric
      Elliott, William Entriken, David Ezell, Nathan George, Reto Gmür, Ryan
      Grant, glauserr, Adrian Gropper, Joel Gustafson, Amy Guy, Lovesh
      Harchandani, Daniel Hardman, Dominique Hazael-Massieux, Jonathan Holt,
      David Hyland-Wood, Iso5786, Renato Iannella, Richard Ishida, Ian Jacobs,
      Anil John, Tom Jones, Rieks Joosten, Gregg Kellogg, Kevin, Eric Korb,
      David I. Lehn, Michael Lodder, Dave Longley, Christian Lundkvist, Jim
      Masloski, Pat McBennett, Adam C. Migus, Liam Missin, Alexander Mühle,
      Anthony Nadalin, Clare Nelson, Mircea Nistor, Grant Noble, Darrell
      O'Donnell, Nate Otto, Matt Peterson, Addison Phillips, Eric Prud'hommeaux,
      Liam Quin, Rajesh Rathnam, Drummond Reed, Yancy Ribbens, Justin Richer,
      Evstifeev Roman, RorschachRev, Steven Rowat, Pete Rowley, Markus
      Sabadello, Kristijan Sedlak, Tzviya Seigman, Reza Soltani, Manu Sporny,
      Orie Steele, Matt Stone, Oliver Terbu, Ted Thibodeau Jr, John Tibbetts,
      Mike Varley, Richard Varn, Heather Vescent, Christopher Lemmer Webber,
      Benjamin Young, Kaliya Young, Dmitri Zagidulin, and Brent Zundel.
    </p>
  </section>
</body>

</html>